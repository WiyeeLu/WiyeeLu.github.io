<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2019/11/08/%E8%B6%85%E5%B8%82%E5%95%86%E5%93%81%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
      <url>/2019/11/08/%E8%B6%85%E5%B8%82%E5%95%86%E5%93%81%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git 简单指导</title>
      <link href="/2019/04/01/Git/"/>
      <url>/2019/04/01/Git/</url>
      
        <content type="html"><![CDATA[<p>Git 是目前世界上最先进的分布式版本控制系统</p><a id="more"></a><h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2><p>版本控制系统是任何能让你了解到一个文件的历史，以及它的发展过程的系统<br>这样，使用版本控制系统就可以让自己和他人协作的时候了解修改了什么，在什么时候修改等</p><h2 id="集中式版本控制系统-分布式版本控制系统"><a href="#集中式版本控制系统-分布式版本控制系统" class="headerlink" title="集中式版本控制系统 / 分布式版本控制系统"></a>集中式版本控制系统 / 分布式版本控制系统</h2><h4 id="集中式版本控制系统"><a href="#集中式版本控制系统" class="headerlink" title="集中式版本控制系统"></a>集中式版本控制系统</h4><p>集中式版本控制系统，版本库是集中存放在中央服务器，需要进行操作的时候，需要先从中央服务器获取最新版本到本地的电脑再进行操作，操作完毕需要把自己修改完的版本推送到中央服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">缺点：</span><br><span class="line">必须要进行联网才可以工作</span><br><span class="line">对于网络的带宽和速度要求较高</span><br></pre></td></tr></table></figure></p><h4 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h4><p>分布式版本控制系统与集中式版本控制系统最大的区别是分布式版本控制系统根本没有“中央服务器”</p><ol><li><p>每个人的电脑上都是一个完整的版本库<br>这样工作的时候就不需要进行联网了，例如两个人都对同一个项目进行了修改，只需要把修改后的版本推送给对方就可以看到对方修改的内容（只是举例，很少这样操作）</p></li><li><p>分布式版本控制系统的安全性能也更高，因为完整的版本库都存在每个人的电脑，某一个人的电脑坏了，不影响整体，可以从任一个人的电脑是进行拷贝，如果是集中式版本控制系统的中央服务器要是出了问题，所有人都工作不了</p></li><li><p>分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已</p></li></ol><h2 id="Git-准备工作"><a href="#Git-准备工作" class="headerlink" title="Git 准备工作"></a>Git 准备工作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;//name</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;//email</span><br><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;//SSH Key</span><br></pre></td></tr></table></figure><p>SSH Key 存在电脑用户目录下的 .ssh ，id_rsa.pub(公钥)</p><h2 id="创建版本库-repository"><a href="#创建版本库-repository" class="headerlink" title="创建版本库 repository"></a>创建版本库 repository</h2><p>即仓库，一个目录，里面所有的文件都被 Git 管理，每个文件的修改、删除等任何操作 Git 都可以跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”</p><ol><li><p>创建一个版本库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir gitTest  //创建文件夹</span><br><span class="line">cd gtiTest //切换到 gitLearn 目录</span><br></pre></td></tr></table></figure></li><li><p>通过以下命令把这个目录变成 Git 管理的仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li></ol><p>Windows:<br><img src="/2019/04/01/Git/1.png" alt="Windows 创建版本库"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -ah</span><br></pre></td></tr></table></figure></p><p>可以看到提示信息，多出了一个 . git 目录，这个目录是用来跟踪管理版本库的，切勿随意改动</p><h4 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h4><p>要使用版本控制系统，文件要以纯文本方式编写文件，因为所有的版本控制系统，只能跟踪文本文件的改动，详细到哪一行修改了哪一个字，但是图片和视频等二进制文件，虽然也可以用版本控制系统管理，但是不能跟踪文件的变动，即到底改了什么，版本控制系统不知道</p><ol><li>在目录下新建一个 wihieree.txt 文本</li><li>使用 git 把文件添加到仓库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add wihieree.txt</span><br><span class="line">git commit -m &quot;add wihieree.txt&quot;</span><br></pre></td></tr></table></figure></li></ol><p><img src="/2019/04/01/Git/8.png" alt="提交修改"><br>add：提出更改（把它们添加到暂存区）<br>commit：实际提交改动，执行完毕后改动提交到 HEAD ，但是还没到远端仓库</p><h4 id="查看仓库当前状态"><a href="#查看仓库当前状态" class="headerlink" title="查看仓库当前状态"></a>查看仓库当前状态</h4><p>修改 wihieree.txt 文件，添加 Wihieree gogogo!! 后运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></p><p>该命令是让我们查看当前仓库的状态：<br><img src="/2019/04/01/Git/2.png" alt="status 查看仓库当前状态"><br>由输出信息可以得知当前仓库的状态，wihieree.txt 被修改过，但是该修改还没有被提交<br>如果想进一步查看修改了什么就可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/01/Git/3.png" alt="查看仓库做过什么修改"><br>从输出可以得知我们在第 1 行增加了一句 wihieree gogogo!!<br>提交修改和文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add wihieree.txt</span><br><span class="line">git commit -m &quot;wihieree gogogo!!&quot;</span><br></pre></td></tr></table></figure></p><h4 id="log-查看日志"><a href="#log-查看日志" class="headerlink" title="log 查看日志"></a>log 查看日志</h4><p>查看日志，可以让我们看到版本的历史记录，知道什么时候哪个版本作了什么修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/01/Git/4.png" alt="查看日志 log"><br>可以看到有 2 次提交，最新的一次 wihieree gogogogit add wihieree.txt<br>最早的一次是 add wihieree.txt    Apr 2 09:39:01 2019<br><strong>log</strong><br>如果想了解本地仓库的历史记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></p><p>可以添加一些参数来修改他的输出，从而得到自己想要的结果:</p><ol><li><p>只看某一个人的提交记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=bob</span><br></pre></td></tr></table></figure></li><li><p>一个压缩后的每一条提交记录只占一行的输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure></li><li><p>通过 ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --oneline --decorate --all</span><br></pre></td></tr></table></figure></li><li><p>看看哪些文件改变了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --name-status</span><br></pre></td></tr></table></figure></li></ol><p>更多参数参考<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --help</span><br></pre></td></tr></table></figure></p><h4 id="版本退回"><a href="#版本退回" class="headerlink" title="版本退回"></a>版本退回</h4><p>HEAD 表示当前版本，上一个版本是 HEAD^ ,上上个版本是 HEAD^^ ，上 20 个版本 HEAD~20 ,以此类推<br>退回上上个版本，再进行查看 wihieree.txt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line">cat wihieree.txt</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/01/Git/5.png" alt="版本退回"><br>可以看到版本被退回， wihieree gogogo!! 不见了<br>若想退回最新的版本，可以回滚找到最新版本的 HEAD，例如我这里是 37c54<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 37c54</span><br></pre></td></tr></table></figure></p><p>这样就可以恢复到最新的版本<br>git reset 既可以回退版本，也可以把暂存区的修改回退到工作区<br>使用 git reflog 命令可以查看输入的每一条命令，这样就可以找到以前版本的 HEAD 使用上面的办法进行回退<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure></p><ul><li><p>当在工作区把某个文件修改错误，想丢弃工作区的修改时，使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure></li><li><p>如上修改错误还进行 git add 提交到了暂存区，想丢弃修改时，使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;</span><br><span class="line">git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure></li></ul><p><strong>hard/mixed/soft</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hard：回退一个版本,清空暂存区,将已提交的内容的版本恢复到本地,本地的文件也将被恢复的版本替换</span><br><span class="line">mixed(默认)：回退一个版本,且会将暂存区的内容和本地已提交的内容全部恢复到未暂存的状态</span><br><span class="line">不影响原来本地文件(未提交的也不受影响) </span><br><span class="line">soft:回退一个版本,不清空暂存区,将已提交的内容恢复到暂存区</span><br><span class="line">不影响原来本地的文件(未提交的也不受影响)</span><br></pre></td></tr></table></figure></p><p><img src="/2019/04/01/Git/9.png" alt><br>Git 工作区、暂存区、版本库之间的关系如上图所示<br><a href="https://www.cnblogs.com/lianghe01/p/5846525.html" target="_blank" rel="noopener">如想进一步了解工作区、暂存区、版本库之间的关系可以点击此处</a><br><a href="https://www.cnblogs.com/kidsitcn/p/4513297.html" target="_blank" rel="noopener">hard/mixed/soft 区别深解可以点击此处</a></p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>新建一个 test.txt ,并提交，然后对它进行删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm test.txt</span><br></pre></td></tr></table></figure></p><p>再查看仓库状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></p><p>这时候就会提示你哪些文件被删除了<br><img src="/2019/04/01/Git/6.png" alt="查看哪些文件被删除"><br>此时可以选择 继续删除文件 或者 从版本库里恢复最新版本的文件（以前版本的找不到，只可以恢复最新版本）</p><ol><li><p>继续删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm test.txt</span><br></pre></td></tr></table></figure></li><li><p>删错了，想恢复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- test.txt</span><br></pre></td></tr></table></figure></li></ol><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>远程仓库是 Git 的杀手锏之一</p><h4 id="远程仓库实际应用"><a href="#远程仓库实际应用" class="headerlink" title="远程仓库实际应用"></a>远程仓库实际应用</h4><p>用一台电脑充当服务器，全天候开机，其他人都从这个服务器仓库克隆一份到自己本地的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交</p><h4 id="Github-营运而生"><a href="#Github-营运而生" class="headerlink" title="Github 营运而生"></a>Github 营运而生</h4><p>GitHub 是通过 Git 进行版本控制的软件源代码托管服务，只需要注册一个 GitHub 账号，就可以免费获得 Git 远程仓库<br>！！该博客也是使用 Github 进行搭建<br>注册完账号，网上寻找添加 SSH Key 的教程，就可以把本地 Git 仓库传输到 Github 仓库<br>若有在不同的电脑上进行提交的需求，也可以把那台电脑的 SHH Key 添加到 Github，这样每台电脑都可以把本地 Git 仓库推送到 Github 仓库上</p><h4 id="推送本地-Git-仓库到-Github-仓库"><a href="#推送本地-Git-仓库到-Github-仓库" class="headerlink" title="推送本地 Git 仓库到 Github 仓库"></a>推送本地 Git 仓库到 Github 仓库</h4><p>在 Github 网站上新建一个 repo ，再把本地 Git 仓库关联到 Github 仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@server-name:path/repo-name.git</span><br></pre></td></tr></table></figure></p><p>关联后，推送 master 分支的所有内容（第一次）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p><p>后续提交新内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><p>这就体现了分布式版本系统的好处，本地工作根本和远程库没关系，没有网络也可以工作，只要在有网络的时候推送到远程库就可以了</p><h4 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h4><p>首先在 Github 新建一个 repo，300498-Stock-analysis<br><img src="/2019/04/01/Git/7.png" alt="Github 新建 repo"><br>克隆一个本地库 git clone<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:WiyeeLu/300498-Stock-analysis.git</span><br></pre></td></tr></table></figure></p><p>Git 支持多种协议，包括 https ，但是通过 ssh 支持的原生 git 协议速度最快</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>分支可以理解为漫威的平行宇宙，我现在学 Java ，另一个平行宇宙的我在学 Python，这时的两个我互不干扰，不过在某个时间点，两个平行宇宙合并了，那时候的我就学会了 Java 又学会了 Python<br>分支是用来将特性开发绝缘开来的。在创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上<br>HEAD 严格来说不是指向提交，而是指向 master，master 才是指向提交的，所以 HEAD 指向的就是当前分支<br><img src="/2019/04/01/Git/10.png" alt="分支"></p><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>创建 dev 分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure></p><p>使用 git branch 查看当前分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\gitLearn&gt;git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure></p><p>前面带有 * 号的表示当前分支<br>在 wihieree.txt 上加上一行 lalala dev<br>进行提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add wihieree.txt</span><br><span class="line">git commit -m &quot;add branch dev&quot;</span><br></pre></td></tr></table></figure></p><p>若工作完成，切换回 master 分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure></p><p>把 dev 分支的工作成果合并到 master 分支上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure></p><p>合并完成就可以删除 dev 分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure></p><p>删除后可查看 branch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></p><p>查看是否只剩 master 分支</p><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成<br>从远程分支抓取最新的提交（更新你的本地仓库至最新改动）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></p><p>建立本地分支与远程分支的连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream dev origin/dev        //dev 为分支名</span><br></pre></td></tr></table></figure></p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交<br>用 git log –graph 命令可以看到分支合并图</p><h4 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h4><p>Git 分支十分强大，在团队开发中应该充分应用。<br>合并分支时，加上 –no-ff 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 fast forward 合并就看不出来曾经做过合并</p><h4 id="BUG-分支"><a href="#BUG-分支" class="headerlink" title="BUG 分支"></a>BUG 分支</h4><p>修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除；<br>当手头工作没有完成时，先把工作现场 git stash 一下，然后去修复 bug，修复后，再 git stash pop ，回到工作现场</p><h4 id="Feature-分支"><a href="#Feature-分支" class="headerlink" title="Feature 分支"></a>Feature 分支</h4><p>开发一个新feature，最好新建一个分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature-vulcan</span><br></pre></td></tr></table></figure></p><p>如果要丢弃一个没有被合并过的分支，可以通过 git branch -D <name> 强行删除</name></p><h4 id="多人协作（推送）"><a href="#多人协作（推送）" class="headerlink" title="多人协作（推送）"></a>多人协作（推送）</h4><p>查看远程库信息，使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></p><p>本地新建的分支如果不推送到远程，对其他人就是不可见的<br>从本地推送分支，使用 git push origin branch-name ，如果推送失败，先用 git pull 抓取远程的新提交；<br>在本地创建和远程分支对应的分支，使用 git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致<br>建立本地分支和远程分支的关联，使用 git branch –set-upstream branch-name origin/branch-name；<br>从远程抓取分支，使用 git pull，如果有冲突，要先处理冲突</p><h4 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h4><p>rebase 操作可以把本地未 push 的分叉提交历史整理成直线<br>rebase 的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比</p><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照<br>tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑在一起</p><p>####新建标签<br>新建一个标签，默认为HEAD，也可以指定一个commit id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;tagname&gt;</span><br></pre></td></tr></table></figure></p><p>指定标签信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</span><br></pre></td></tr></table></figure></p><p>查看所有标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure></p><h4 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h4><p>若操作失误，可以使用下面的命令替换掉本地改动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;filename&gt;</span><br></pre></td></tr></table></figure></p><p>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件<br>已添加到暂存区的改动以及新文件都不会受到影响</p><p>假如想丢弃在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将本地主分支指向它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure></p><h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">mkdir<span class="comment">//创建新目录</span></span><br><span class="line">git init    <span class="comment">//初始化一个 Git 仓库</span></span><br><span class="line">git add &lt;fileName&gt;      <span class="comment">//提交修改，可提交多次，把文件添加到暂存区</span></span><br><span class="line">git commit -m &lt;message&gt;     <span class="comment">//提交所有文件，把暂存区的所有内容提交到当前分支</span></span><br><span class="line">git status      <span class="comment">//查看仓库当前的状态</span></span><br><span class="line">git log     <span class="comment">//查看日志，什么时候修改了什么</span></span><br><span class="line">cat &lt;file&gt;<span class="comment">//查看文件内容</span></span><br><span class="line">git reset --hard commit_id      <span class="comment">//可以在不同的版本间恢复</span></span><br><span class="line">git reflog      <span class="comment">//查看命令历史，以便要回到未来的某一个版本</span></span><br><span class="line">git diff HEAD -- wihieree.txt       <span class="comment">//查看工作区和版本库里面最新版本的区别</span></span><br><span class="line">git checkout -- wihieree.txt        <span class="comment">//把 wihieree.txt 文件在工作区的修改全部撤销，即回到最近一次 git commit 或 git add 时的状态</span></span><br><span class="line">git reset HEAD &lt;file&gt;       <span class="comment">//在 commit 之前，可以使用这个命令把暂存区的修改撤销掉，重新放回工作区</span></span><br><span class="line">git rm &lt;file&gt;     <span class="comment">//删除一个文件</span></span><br><span class="line">git checkout -- &lt;file&gt;      //删错了文件，只要版本库里还有，就可以使用该命令恢复版本库里的最新版本</span><br><span class="line">git remote add origin git@server-name:path/repo-name.git    //把本地 Git 仓库关联到 Github 仓库</span><br><span class="line">    eg. git remote add origin git@github.com:WiyeeLu/Wens-Stock-analysis.git</span><br><span class="line">git clone username@host:/path/to/repository//把 GitHub 仓库克隆到本地</span><br><span class="line">git push -u origin master       //推送 master 分支的所有内容（第一次）</span><br><span class="line">git push origin master      //后续提交新内容</span><br><span class="line">git branch      //查看分支</span><br><span class="line">git branch &lt;name&gt;       //创建分支</span><br><span class="line">git checkout &lt;name&gt;     //切换分支</span><br><span class="line">git checkout -b &lt;name&gt;      //创建 + 切换分支</span><br><span class="line">git merge &lt;name&gt;        //合并某分支到当前分支</span><br><span class="line">git branch -d &lt;name&gt;        //删除分支</span><br><span class="line">git log --graph     //查看分支合并图</span><br><span class="line">git merge --no-ff -m "merge with no-ff" dev     //用普通模式合并，合并后的历史有分支</span><br><span class="line">git stash       //把当前工作现场“存储”起来</span><br><span class="line">git stash pop       //回到工作现场</span><br><span class="line">git remote -v       //查看远程库信息</span><br><span class="line">git push origin branch-name     //从本地推送分支</span><br><span class="line">git pull        //抓取远程的新提交（更新你的本地仓库至最新改动）</span><br><span class="line">git checkout -b branch-name origin/branch-name      //本地创建和远程分支对应的分支</span><br><span class="line">git branch --set-upstream branch-name origin/branch-name    //建立本地分支和远程分支的关联</span><br><span class="line">git rebase      //可以把本地未 push 的分叉提交历史整理成直线</span><br><span class="line">git tag &lt;tagname&gt;       //用于新建一个标签，默认为HEAD，也可以指定一个commit id</span><br><span class="line">git tag -a &lt;tagname&gt; -m "blablabla..."      //可以指定标签信息</span><br><span class="line">git tag     //可以查看所有标签</span><br><span class="line">git push origin &lt;tagname&gt;       //可以推送一个本地标签</span><br><span class="line">git push origin --tags      //可以推送全部未推送过的本地标签</span><br><span class="line">git tag -d &lt;tagname&gt;        //可以删除一个本地标签</span><br><span class="line">git push origin :refs/tags/&lt;tagname&gt;        //可以删除一个远程标签</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java图形用户界面基础</title>
      <link href="/2019/03/31/Java%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/03/31/Java%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>为 Java GUI 程序设计而设计的 API 是应用面向对象原理的绝佳范例<br>GUI 全称是 Graphical User Interface，简单的说是图形用户界面<br>GUI 只有在桌面操作系统中才存在</p><a id="more"></a><h2 id="Swing-和-AWT"><a href="#Swing-和-AWT" class="headerlink" title="Swing 和 AWT"></a>Swing 和 AWT</h2><p>不依赖于自己 GUI 的 Swing 组件称为轻量级组件（即对系统依赖性较弱），而 AWT 组件称为重量级组件（对系统依赖性较强）<br>AWT 用户界面组件终究是要退出历史舞台，但是 Swing 组件不能取代 AWT 中的全部类，只能替代 AWT GUI 的组件类，AWT 辅助类在 GUI 程序设计中仍然很有用</p><h4 id="AWT-缺点"><a href="#AWT-缺点" class="headerlink" title="AWT 缺点"></a>AWT 缺点</h4><p>AWT 组件最大的缺陷就是它依赖于操作系统，也就是说 AWT 程序运行在不同的操作系统上会有不同的外观和行为，这和 Java 的平台无关性是不符合的</p><h4 id="Swing-优点"><a href="#Swing-优点" class="headerlink" title="Swing 优点"></a>Swing 优点</h4><p>Swing 组件是在 AWT 组件上发展而来的轻量级组件，与 AWT 相比不但改进了用户界面，而且所需的系统资源更少<br>Swing 是纯 Java 组件，使得应用程序在不同的平台上运行时具有相同的外观和相同的行为</p><h2 id="Java-GUI-API"><a href="#Java-GUI-API" class="headerlink" title="Java GUI API"></a>Java GUI API</h2><p>GUI API 包含的类可以分成三个组：组件类（component class）、容器类（container class）和辅助类（helper class）<br>组件类是用来创建用户界面的，例如：JButton、JLable 和 JTextField<br>容器类是用来包含其他组件的，例如：JFrame、JPanel 和 JApplet<br>辅助类是用来支持 GUI 组件，例如：Graphics、Color、Font、FontMetrics 和 Dimension</p><h4 id="组件类"><a href="#组件类" class="headerlink" title="组件类"></a>组件类</h4><p>Component 类的实例可以显示在屏幕上，是包括容器类的所有用户界面类的根类<br>JComponent 类是所有轻量级 Swing 组件类的根类<br>Component 类和 JComponent 类都是抽象类</p><h4 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h4><p>一个 Container 的实例可以包含 Component 实例<br>容器类是用于盛装其他 GUI 组件的 GUI 组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        容器类                                                          说  明</span><br><span class="line">java.awt.Container                          用于对组件分组。框架 Frame、面板 Panel 和 applet 都是它的子类</span><br><span class="line">java.swing.JFrame                           一个不能包含在另一个窗口中的窗口。在 Java GUI 应用程序中，它用于存放其他 Swing 用户界面组件</span><br><span class="line">java.swing.JPanel                           一个存放用户界面组件的不可见的容器。面板可以嵌套。可以将面板放在包含面板的容器中。JPanel 也可用作画图的画布</span><br><span class="line">java.swing.JApplet                          Applet 的一个子类。必须扩展 JApplet 才能创建基于 Swing 的 Java appet</span><br><span class="line">java.swing.JDialog                          一个弹出式窗口或消息框，一般用作接收来自用户的附加信息或通知事件发生的临时窗口</span><br></pre></td></tr></table></figure><h4 id="GUI-辅助类"><a href="#GUI-辅助类" class="headerlink" title="GUI 辅助类"></a>GUI 辅助类</h4><p>辅助类都不是 Component 的子类，它们用来描述 GUI 组件的属性，例如：图形的内容、颜色、字体以及大小尺寸等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        辅助类                                                          说  明</span><br><span class="line">java.awt.Graphics                           一个抽象类，提供绘制字符串、线和简单几何图形的方法</span><br><span class="line">java.awt.Color                              处理 GUI 组件的颜色</span><br><span class="line">java.awt.Font                               指定 GUI 组件上文本和图形的字体</span><br><span class="line">java.awt.FontMetrics                        一个获取字体属性的抽象类</span><br><span class="line">java.awt.Dimension                          将组件的宽度和高度（以整数为精度）封装在单个对象中</span><br><span class="line">java.awt.LayoutManager                      指定组件在容器中如何放置</span><br></pre></td></tr></table></figure><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>创建一个用户界面需要创建一个框架或一个 applet 来存放用户界面组件</p><h2 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h2><p>可以动态地改变布局管理器的属性<br>FlowLayout（流式布局）具有属性 alignment、hgap 和 vgap，可以使用 setAlignment、setHgap 和 setVgap 方法来表明对齐方式、水平间隔和垂直间隔<br>GridLayout（网格布局）具有属性 rows、columns、hgap 和 vgap，可以使用 setRows、setColums、setHgap 和 setVgap 方法来指定行数、列数以及水平间隔和垂直间隔<br>BorderLayout（边界布局）具有属性 hgap 和 vgap，可以使用 setHgap 和 setVgap 方法来指定水平间隔和垂直间隔<br>框架默认的布局是 BorderLayout，所以在框架中想要使用 BorderLayout，可以不进行指定，直接使用即可，JPanel 默认的布局是FlowLayout 即流式布局</p><h2 id="Swing-GUI-组件的公共特性"><a href="#Swing-GUI-组件的公共特性" class="headerlink" title="Swing GUI 组件的公共特性"></a>Swing GUI 组件的公共特性</h2><p>Component 类是所有 GUI 组件和容器的根，所有 Swing GUI 组件（除了 JFrame、JApplet 和 JDialog）都是 JComponent 的子类</p><h4 id="Swing-GUI-组件常用的操作方法"><a href="#Swing-GUI-组件常用的操作方法" class="headerlink" title="Swing GUI 组件常用的操作方法"></a>Swing GUI 组件常用的操作方法</h4><p><img src="/2019/03/31/Java图形用户界面基础/1.png" alt="Swing GUI 组件常用的操作方法"><br>所有 Swing GUI 组件都继承 Component、Container 和 JComponent 的公共方法</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> GUI </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 二进制I/O</title>
      <link href="/2019/03/29/Java-%E4%BA%8C%E8%BF%9B%E5%88%B6I-O/"/>
      <url>/2019/03/29/Java-%E4%BA%8C%E8%BF%9B%E5%88%B6I-O/</url>
      
        <content type="html"><![CDATA[<p>Java 文本与二进制 I/O 总结(Java 流 Stream、文件 File 和 IO)</p><a id="more"></a><h2 id="文本-I-O-与二进制-I-O"><a href="#文本-I-O-与二进制-I-O" class="headerlink" title="文本 I/O 与二进制 I/O"></a>文本 I/O 与二进制 I/O</h2><p>二进制 I/O 不涉及编码和解码，因此更高效<br>文本 I/O 建立在二进制 I/O 的基础之上，它提供一层抽象，用于字符层次自动进行的编码和解码<br>Java 的类文件存储为二进制文件。因为二进制文件与主机编码方案无关，可移植，在任何机器上的 Java 程序可以读取 Java 程序创建的二进制文件。</p><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>流 (stream) 的概念源于 UNIX 中管道 (pipe) 的概念。在 UNIX 中，管道是一条不间断的字节流，用来实现程序或进程间的通信，或读写外围设备、外部文件等<br>形象的比喻：水流    文件 ——– 程序，文件和程序之间连接一个管道，水流就在之间形成了，自然就有方向，可以流进，也可以流出，即  流  就是一个管道里面有流水，这个管道连接了文件和程序</p><h4 id="数据流分类"><a href="#数据流分类" class="headerlink" title="数据流分类"></a>数据流分类</h4><p>流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种：</p><ul><li>字节流：数据流中最小的数据单元是字节</li><li>字符流：数据流中最小的数据单元是字符， Java 中的字符是 Unicode 编码，一个字符占用两个字节<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    字节流                  字符流</span><br><span class="line">输入流 InputStream          Reader</span><br><span class="line">输出流 OutputStream         Writer</span><br></pre></td></tr></table></figure></li></ul><p>Java 的字符流，采用的是 Unicode 标准，16 位，两个字节<br>reader 是所有读取字符串输入流的祖先，而 writer 是所有输出字符串输出流的根类。 </p><h2 id="I-O-概览"><a href="#I-O-概览" class="headerlink" title="I/O 概览"></a>I/O 概览</h2><p>Java.io 包中最重要的就是 5 个类和 1 个接口：</p><ul><li>类：File      OutputStream        InputStream     Writer      Reader</li><li>接口：Serializable</li></ul><h4 id="I-O-层次"><a href="#I-O-层次" class="headerlink" title="I/O 层次"></a>I/O 层次</h4><p>分为 3 层<br><img src="/2019/03/29/Java-二进制I-O/1.png" alt="I/O 层次"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等</span><br><span class="line">2. InputStream（字节流，二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征</span><br><span class="line">3. OutputStream（字节流，二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征</span><br><span class="line">4. Reader（字符流，文本格式操作）：抽象类，基于字符的输入操作</span><br><span class="line">5. Writer（字符流，文本格式操作）：抽象类，基于字符的输出操作</span><br><span class="line">6. RandomAccessFile（随机文件操作）：它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作</span><br></pre></td></tr></table></figure></p><h2 id="I-O-流"><a href="#I-O-流" class="headerlink" title="I/O 流"></a>I/O 流</h2><p>java.io 包里有 4 个基本类：InputStream、OutputStream 及 Reader、Writer 类，它们分别处理字节流和字符流，其他流都是由这 4 个派生出来的：<br><img src="/2019/03/29/Java-二进制I-O/2.png" alt="I/O 流"></p><h2 id="InputStream-类和-OutputStream-类"><a href="#InputStream-类和-OutputStream-类" class="headerlink" title="InputStream 类和 OutputStream 类"></a>InputStream 类和 OutputStream 类</h2><p>InputStream 为字节输入流，它本身为一个抽象类，必须依靠其子类实现各种功能，此抽象类是表示字节输入流的所有类的超类。继承自 InputStream 的流都是向程序中输入数据的，且数据单位为字节（8bit）<br>OutputStream 和 InputStream 是相对应的</p><h4 id="FileInputStream-和-FileOutputStream"><a href="#FileInputStream-和-FileOutputStream" class="headerlink" title="FileInputStream 和 FileOutputStream"></a>FileInputStream 和 FileOutputStream</h4><p>一个流被定义为一个数据序列，输入流用于从源读取数据，输出流用于向目标写数据</p><h6 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h6><p>FileInputStream 用于从文件读取数据，它的对象可以用关键字 new 来创建<br>有多种构造方法可用来创建对象：</p><ol><li><p>可以使用字符串类型的文件名来创建一个输入流对象来读取文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream f = <span class="keyword">new</span> FileInputStream(<span class="string">"C:/kt"</span>);</span><br></pre></td></tr></table></figure></li><li><p>也可以使用一个文件对象来创建一个输入流对象来读取文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"C:/kt"</span>);</span><br><span class="line">InputStream out = <span class="keyword">new</span> FileInputStream(f);</span><br></pre></td></tr></table></figure></li></ol><h6 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h6><p>该类用来创建一个文件并向文件中写数据<br>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件<br>有两个构造方法可以用来创建 FileOutputStream 对象</p><ol><li><p>使用字符串类型的文件名来创建一个输出流对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">"C:/kt"</span>);</span><br></pre></td></tr></table></figure></li><li><p>也可以使用一个文件对象来创建一个输出流来写文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"C:/kt"</span>);</span><br><span class="line">OutputStream f = <span class="keyword">new</span> FileOutputStream(f);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> I/O </tag>
            
            <tag> 二进制 </tag>
            
            <tag> 文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java String类</title>
      <link href="/2019/03/29/Java-String%E7%B1%BB/"/>
      <url>/2019/03/29/Java-String%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>Java 中字符串的支持是通过在 JDK 中提供一个名为 String 的类，对应字符串这个变量类型</p><a id="more"></a><h2 id="String-类的特点"><a href="#String-类的特点" class="headerlink" title="String 类的特点"></a>String 类的特点</h2><ul><li>String 类的底层使用 char 的数组保存数据</li><li>String 类是一个 final 类，不允许被继承</li><li>String 类是一个 immutable 类，该类的对象生成后，内容不会发生变化。该类中的所有返回 String 类型对象的成员方法都是返回一个新的 String 对象</li><li>方法区中有一块区域名为“常量区”, 用于存储编译时和运行时的字符串常量</li></ul><h2 id="String-类方法"><a href="#String-类方法" class="headerlink" title="String 类方法"></a>String 类方法</h2><p>String 类作为对应字符串的类，该类中含有大量的方法用来完成字符串相关的构造、裁剪、拼接与替换等功能，大部分为方法重载</p><h2 id="创建对象的两种方式"><a href="#创建对象的两种方式" class="headerlink" title="创建对象的两种方式"></a>创建对象的两种方式</h2><p>Java 中的字符串对象比较特殊，比普通 Java 类有多一种创建对象的方法，即“字符序列法”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String strA = <span class="string">"WiHieree"</span>;</span><br><span class="line">String strB = <span class="keyword">new</span> String(<span class="string">"WiHieree"</span>);</span><br></pre></td></tr></table></figure></p><p>以上两种方式创建的对象区别：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String strA = <span class="string">"Wihieree"</span>;</span><br><span class="line">        String strB = <span class="string">"Wihieree"</span>;</span><br><span class="line">        System.out.println(strA == strB);</span><br><span class="line">        System.out.println(strA.equals(strB));</span><br><span class="line"></span><br><span class="line">        String strC = <span class="keyword">new</span> String(<span class="string">"Wiyee"</span>);</span><br><span class="line">        String strD = <span class="keyword">new</span> String(<span class="string">"Wiyee"</span>);</span><br><span class="line">        System.out.println(strC == strD);</span><br><span class="line">        System.out.println(strC.equals(strD));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure></p><p>机制在于JVM内存模型的方法区中有一个 String 常量池（方法去内存），对于使用字符序列方式创建对象，JVM首先会查看字符串常量池中是否已经存在该对象，如果存在，则直接已存在对象而不会新建对象；对于使用 new 运算符方式创建对象，JVM会直接在堆中分配一个新的String对象，如下图所示：<br><img src="/2019/03/29/Java-String类/1.jpg" alt="代码片段的内存布局见图"></p><h4 id="字符串的比较（equals-与-）"><a href="#字符串的比较（equals-与-）" class="headerlink" title="字符串的比较（equals 与 ==）"></a>字符串的比较（equals 与 ==）</h4><ul><li>对于 ==，如果作用与基本数据类型（byte、short、char、int、long、float、double、boolean）的变量,则比较的是其存储的“值”是否相等；如果作用与引用类型的变量，则比较其所指向的对象的地址是否相同（即是否同一个对象）。在 Java 中，String 是引用类型</li><li>String的 equals 方法继承自 Java 中的超级父类 Object，Object 的 equals 方法用来比较两个对象的引用是否相等（即是否同一个对象）。但是，String 的 equals 方法不仅是简单地继承，而是进行了重写(Override)，用来比较两个 String 对象所存储的字符序列值是否相等</li></ul><h2 id="intren-方法"><a href="#intren-方法" class="headerlink" title="intren 方法"></a>intren 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String strA = <span class="string">"WiHieree"</span>;</span><br><span class="line">        String strB = <span class="keyword">new</span> String(<span class="string">"WiHieree"</span>);</span><br><span class="line">        System.out.println(strA.intern().equals(strB.intern()));</span><br><span class="line">        System.out.println(strA.intern() == strB.intern());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>无论是字符串常量区中的 String 对象，还是堆内存中的 String 对象，它们的 intern 方法都是去 JVM 中的字符串常量区获取相等字符序列的 String 对象返回</p><h2 id="值传递-引用传递"><a href="#值传递-引用传递" class="headerlink" title="值传递/引用传递"></a>值传递/引用传递</h2><p>Java 中只有值传递机制，而没有引用传递机制，所以 String 参数是值传递方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String arg = <span class="keyword">new</span> String(<span class="string">"WiHieree"</span>);</span><br><span class="line">        change(arg);</span><br><span class="line">        System.out.println(<span class="string">"main arg ---&gt; "</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">        arg = <span class="string">"Wiyee"</span>;</span><br><span class="line">        System.out.println(<span class="string">"chang arg ---&gt; "</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">chang arg ---&gt; Wiyee</span><br><span class="line">main arg ---&gt; WiHieree</span><br></pre></td></tr></table></figure></p><h2 id="字符串与数组之间的转换"><a href="#字符串与数组之间的转换" class="headerlink" title="字符串与数组之间的转换"></a>字符串与数组之间的转换</h2><p>字符串不是数组，但是字符串可以转换成数组，反之亦然<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">字符 ----&gt; 数组         toCharArray         <span class="keyword">char</span>[] chars = <span class="string">"WiHieree"</span>.toCharArray();</span><br><span class="line">数组 ----&gt; 字符     String str = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'W'</span>,<span class="string">'i'</span>,<span class="string">'y'</span>,<span class="string">'e'</span>,<span class="string">'e'</span>&#125;);</span><br><span class="line">                   String str = String.valueOf(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'W'</span>,<span class="string">'i'</span>,<span class="string">'y'</span>,<span class="string">'e'</span>,<span class="string">'e'</span>&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="String、StringBuffer-和-StringBuilder-的区别"><a href="#String、StringBuffer-和-StringBuilder-的区别" class="headerlink" title="String、StringBuffer 和 StringBuilder 的区别"></a>String、StringBuffer 和 StringBuilder 的区别</h2><h4 id="对象的可变与不可变"><a href="#对象的可变与不可变" class="headerlink" title="对象的可变与不可变"></a>对象的可变与不可变</h4><p>StringBuffer/StringBuilder 类是可以替代 String 类的另一种处理字符串的解决方案，比 String 类更灵活<br>可以给一个 StringBuilder或StringBuffer 中添加、插入或追加新的内容，但是 String 对象一旦创建，它的值就确定了</p><h4 id="效率-使用-StringBuffer-连接字符串"><a href="#效率-使用-StringBuffer-连接字符串" class="headerlink" title="效率(使用 StringBuffer 连接字符串)"></a>效率(使用 StringBuffer 连接字符串)</h4><p>除了 StringBuffer 中修改缓冲区的方法是同步的之外，StringBuilder 类与 StringBuffer 类是很相似的<br>如果是多任务并发访问，就使用 StringBuffer ；而如果是单任务访问，使用 StringBuilder 会更有效<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+StringBuilder()                        构建一个容量为 <span class="number">16</span> 的空的字符串生成器</span><br><span class="line">+StringBuilder(capacity: <span class="keyword">int</span>)           构建一个指定容量的字符串生成器</span><br><span class="line">+StringBuilder(s: String)               构建一个带指定字符串的字符串生成器</span><br></pre></td></tr></table></figure></p><p>eg. +append(data: char[]): StringBuilder 将字符串和字符追加到字符串生成器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder a = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        a.append(<span class="string">"Welcome"</span>);</span><br><span class="line">        a.append(<span class="string">" "</span>);</span><br><span class="line">        a.append(<span class="string">"to"</span>);</span><br><span class="line">        a.append(<span class="string">" "</span>);</span><br><span class="line">        a.append(<span class="string">"WiyeeLu's blog"</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">Welcome to WiyeeLu<span class="string">'s blog</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常</title>
      <link href="/2019/03/27/Java%E5%BC%82%E5%B8%B8/"/>
      <url>/2019/03/27/Java%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>异常的处理机制可以确保我们程序的健壮性，提高系统可用率</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>异常情形是指阻止当前方法或者作用域继续执行的问题<br>Java 中采用“类”去模拟异常，类可以创建对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NullPointerException e = <span class="number">0x1234</span>;</span><br><span class="line">e 是引用类型， e 中保存的内存地址指向堆中的“对象”</span><br><span class="line">这个对象一定是 NullPointerException 类型</span><br><span class="line">这个对象就表示真实存在的异常事件</span><br><span class="line">NullPointerException 则表示一类异常</span><br></pre></td></tr></table></figure></p><p>出现异常的情况：只有在当前的环境下程序无法正常运行，这时它就会从当前环境中跳出，并抛出异常</p><ul><li>用户输入了非法数据</li><li>要打开的文件不存在</li><li>网络通信时连接中断，或者 JVM 内存溢出</li></ul><h3 id="异常处理机制的作用"><a href="#异常处理机制的作用" class="headerlink" title="异常处理机制的作用"></a>异常处理机制的作用</h3><p>程序发生异常事件之后，为我们输出详细的信息，程序员通过这个信息，可以对程序进行处理，使程序更加健壮</p><p>eg. JVM 自动创建 ArithMeticException 类型的对象包含了对象的详细信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = a/b; <span class="comment">//JVM 自动创建了对象</span></span><br><span class="line">        <span class="comment">//ArithMeticException e = 0x2356;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="异常的用途"><a href="#异常的用途" class="headerlink" title="异常的用途"></a>异常的用途</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> i = devide(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">devide</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断除数是否为0</span></span><br><span class="line">        <span class="keyword">if</span>(num2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"除数不能为零"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num1/num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序编译通过了，但是运行时出现了异常，表示发生某个异常事件<br>JVM 向控制台输出了如下信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ArithmeticException: / by zero</span><br><span class="line">at com.day032801.ExceptionTest01.main(ExceptionTest01.java:<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p><p>本质：程序执行过程中发生了算数异常事件，JVM 为我们创建了一个 ArithMeticException 类型的对象<br>并且这个对象中包含了详细的异常信息，并且 JVM 将这个对象中的信息输出到控制台</p><h3 id="异常的体系结构"><a href="#异常的体系结构" class="headerlink" title="异常的体系结构"></a>异常的体系结构</h3><p>通过以上示例，可以看到 Java 给我们提供了这样的体系结构：当出现问题的时候，它会告诉我们，并且把错误的详细信息也告诉我们了，这就是异常的体系结构，这样我们的程序就会更健壮，我们可以把这个信息再进行处理一下，告诉用户。从上面大家还可以看到，Java 异常都是类，在异常对象中会携带一些信息给我们，我们可以通过这个异常对象把信息取出来</p><h2 id="异常类的层次结构"><a href="#异常类的层次结构" class="headerlink" title="异常类的层次结构"></a>异常类的层次结构</h2><p><img src="/2019/03/27/Java异常/1.png" alt="异常类的层次结构"></p><h3 id="常见的异常类型"><a href="#常见的异常类型" class="headerlink" title="常见的异常类型"></a>常见的异常类型</h3><p><img src="/2019/03/27/Java异常/2.png" alt="常见的异常类型"></p><h4 id="常见异常类型的处理方案"><a href="#常见异常类型的处理方案" class="headerlink" title="常见异常类型的处理方案"></a>常见异常类型的处理方案</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. java.lang.NullPointerException(空指针异常)</span><br></pre></td></tr></table></figure><p>空指针异常发生在对象为空，但是引用了这个对象的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">null</span>;<span class="comment">//此时 s 为空</span></span><br><span class="line"><span class="keyword">int</span> length = s.length();<span class="comment">//发生空指针异常</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>. java.lang.ClassNotFoundException(指定的类型不存在)</span><br></pre></td></tr></table></figure><p>检查类的名称和路径是否正确，比如调用 Class.forName() ,类的名称不正确</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>.java.lang.NumberFormatException(字符串转换为数字异常)</span><br></pre></td></tr></table></figure><p>当试图将一个 String 转换为指定的数字类型，而该字符串却不满足数字类型要求的格式时，抛出该异常<br>如现在讲字符型的数据 123456 转换为数值型数据时，是允许的<br>但是如果字符型数据中包含了非数字型的字符，如 123#56 ，此时转换为数值型时就会出现异常。系统就会捕捉到这个异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>.java.lang.IndexOutOfBoundsException(数组下标越界异常)</span><br></pre></td></tr></table></figure><p>调用数组超过数组的长度，最好先查看一下数组的length，以免出现这个异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>.java.lang.IllegalArgumentException(方法的参数错误)</span><br></pre></td></tr></table></figure><p>比如 g.setColor(int red,int green,int blue) 这个方法中的三个值，如果有超过 255 的也会出现这个异常，因此一旦发现这个异常，我们要做的，就是赶紧去检查一下方法调用中的参数传递是不是出现了错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span>.java.lang.IllegalAccessException(没有访问权限)</span><br></pre></td></tr></table></figure><p>当应用程序要调用一个类，但当前的方法即没有对该类的访问权限便会出现这个异常。对程序中用了 Package 的情况下要注意这个异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span>.java.lang.ArithmeticException(数学运算异常)</span><br></pre></td></tr></table></figure><p>当算术运算中出现了除以零这样的运算就会出这样的异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span>.java.lang.ClassCastException(数据类型转换异常)</span><br></pre></td></tr></table></figure><p>当试图将对某个对象强制执行向下转型，但该对象又不可转换为其子类的实例时将引发该异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span>.java.lang.FileNotFoundException(文件未找到异常)</span><br></pre></td></tr></table></figure><p>当程序试图打开一个不存在的文件进行读写时将会引发该异常。该异常由 FileInputStream,FileOutputStream,RandomAccessFile 的构造器声明抛出<br>即使被操作的文件存在，但是由于某些原因不可访问，比如打开一个只读文件进行写入，这些构造方法仍然会引发异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>.java.lang.NoSuchMethodException(方法不存在异常)</span><br></pre></td></tr></table></figure><p>当程序试图访问(修改或读取)某个方法，但是该方法不存在就会引发异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>.java.lang.InstantiationException(实例化异常)</span><br></pre></td></tr></table></figure><p>当试图通过 Class 的 newInstance() 方法创建某个类的实例,但程序无法通过该构造器来创建该对象时引发</p><ul><li>Class 对象表示一个抽象类，接口，数组类，基本类型</li><li>该 Class 表示的类没有对应的构造器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>.java.lang.OutOfMemoryException(内存不足错误)</span><br></pre></td></tr></table></figure><p>当可用内存不足以让 Java 虚拟机分配给一个对象时抛出该错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span>.java.lang.NoClassDefFoundException(未找到类定义错误)</span><br></pre></td></tr></table></figure><p>当 Java 虚拟机或者类装载器试图实例化某个类，而找不到该类的定义时抛出该错误<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>  违背安全原则异常：SecturityException</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>  操作数据库异常：SQLException</span><br><span class="line"></span><br><span class="line"><span class="number">16</span>  输入输出异常：IOException</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>  通信异常：SocketException</span><br></pre></td></tr></table></figure></p><h3 id="异常处理机制的主要组成"><a href="#异常处理机制的主要组成" class="headerlink" title="异常处理机制的主要组成"></a>异常处理机制的主要组成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try：监控有可能产生异常的语句块</span><br><span class="line">catch：以合理的方式捕获并处理异常</span><br><span class="line">finally：不管有无异常，一定会执行的语句块（一般用来释放资源等）</span><br><span class="line">throw：手动引发异常</span><br><span class="line">throws：指定由方法引发的异常</span><br></pre></td></tr></table></figure><h4 id="throw-throws"><a href="#throw-throws" class="headerlink" title="throw\throws"></a>throw\throws</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="try…catch…finally"><a href="#try…catch…finally" class="headerlink" title="try…catch…finally"></a>try…catch…finally</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//所监控的有可能产生异常的语句块</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;<span class="comment">//捕获异常，e 就是所捕获的异常对象</span></span><br><span class="line">    <span class="comment">//异常处理：打印异常信息、日志记录等</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//不管有无异常，一定会执行的语句块（一般用来释放资源）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>catch 语块可以写多个，但是必须从上到下，从小到大（子类 –&gt; 父类）</p><h4 id="深入-throws"><a href="#深入-throws" class="headerlink" title="深入 throws"></a>深入 throws</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line">        m1();</span><br><span class="line">        <span class="comment">//不会输出</span></span><br><span class="line">        System.out.println(<span class="string">"Wihieree"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(<span class="string">"c:/ab.txt"</span>);</span><br><span class="line">        <span class="comment">//FileInputStream 构造方法声明位置上使用 throws（向上抛）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.io.FileNotFoundException: c:\ab.txt (系统找不到指定的文件。)</span><br><span class="line">at java.base/java.io.FileInputStream.open0(Native Method)</span><br><span class="line">at java.base/java.io.FileInputStream.open(FileInputStream.java:<span class="number">219</span>)</span><br><span class="line">at java.base/java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:<span class="number">157</span>)</span><br><span class="line">at java.base/java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:<span class="number">112</span>)</span><br><span class="line">at com.day032801.ExceptionTest03.m3(ExceptionTest03.java:<span class="number">20</span>)</span><br><span class="line">at com.day032801.ExceptionTest03.m2(ExceptionTest03.java:<span class="number">16</span>)</span><br><span class="line">at com.day032801.ExceptionTest03.m1(ExceptionTest03.java:<span class="number">12</span>)</span><br><span class="line">at com.day032801.ExceptionTest03.main(ExceptionTest03.java:<span class="number">6</span>)</span><br></pre></td></tr></table></figure></p><p>使用 throws 处理异常不是真正处理异常而是推卸责任，谁调用的就会抛给谁<br>因为 m1 方法出现异常采用的是上抛，给了 JVM , JVM 遇到这个异常就会退出 JVM ，下面的程序不会执行<br>所以不会输出 Wihieree<br>出现上面输出结果的原因是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在程序运行过程中发生了 FileNotFoundException 类型的异常</span><br><span class="line">JVM 为我们创建了一个 FileNotFoundException 类型的对象</span><br><span class="line">该对象中携带上面的信息，JVM 负责将该对象的信息打印到控制台，并且 JVM 停掉了程序的运行</span><br></pre></td></tr></table></figure></p><h4 id="深入-try…catch…"><a href="#深入-try…catch…" class="headerlink" title="深入 try…catch…"></a>深入 try…catch…</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//程序执行到此处发生了 FileNotFoundException 类型的异常</span></span><br><span class="line">            <span class="comment">//JVM 会自动创建一个 FileNotFoundException 类型的对象</span></span><br><span class="line">            <span class="comment">//将该对象的内存地址赋值给 catch 语句块中的 e 变量</span></span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"abc"</span>);</span><br><span class="line">            <span class="comment">//上面的代码出现了异常，try 语句块的代码不再继续执行，直接进入 catch 语句块中执行</span></span><br><span class="line">            System.out.println(<span class="string">"WiHieree"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">            <span class="comment">//e 内存地址指向堆中的那个对象是 “FileNotFoundException 类型的”事件</span></span><br><span class="line">            System.out.println(<span class="string">"读取的文件不存在！"</span>);</span><br><span class="line">            <span class="comment">//FileNotFoundException 将 Object 中的 toString 方法重写</span></span><br><span class="line">            System.out.println(e);<span class="comment">//java.io.FileNotFoundException: abc (系统找不到指定的文件。)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getMessage-和-printStackTrace-方法"><a href="#getMessage-和-printStackTrace-方法" class="headerlink" title="getMessage() 和 printStackTrace() 方法"></a>getMessage() 和 printStackTrace() 方法</h4><p>printStackTrace() 输出信息更详细，更适合用于调试程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"abc"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打印异常堆栈信息</span></span><br><span class="line">            <span class="comment">//一般情况下都会使用该方式去调试程序</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            java.io.FileNotFoundException: abc (系统找不到指定的文件。)</span></span><br><span class="line"><span class="comment">            at java.base/java.io.FileInputStream.open0(Native Method)</span></span><br><span class="line"><span class="comment">            at java.base/java.io.FileInputStream.open(FileInputStream.java:219)</span></span><br><span class="line"><span class="comment">            at java.base/java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:157)</span></span><br><span class="line"><span class="comment">            at java.base/java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:112)</span></span><br><span class="line"><span class="comment">            at com.day032801.ExceptionTest04.main(ExceptionTest04.java:9)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            String msg = e.getMessage();</span><br><span class="line">            System.out.println(msg);    <span class="comment">//abc (系统找不到指定的文件。)上面方法的简略</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这段代码会执行</span></span><br><span class="line">        System.out.println(<span class="string">"WiHieree"</span>);<span class="comment">//WiHieree</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="finally-关键字"><a href="#finally-关键字" class="headerlink" title="finally 关键字"></a>finally 关键字</h4><p>finally 语句块可以直接和 try 语句块联用   try…finally…<br>try…catch…finally 也可以<br>在 finally 语句块中的代码是一定会执行的，但只要在 finally 之前退出了 JVM，finally 语句就不会执行<br>eg. System.exit(0);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深入 finally 语句块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m1();</span><br><span class="line">        System.out.println(<span class="string">"main 的 i --&gt; "</span> + i);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">//10</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(<span class="string">"finally 的 i --&gt; "</span> + i);<span class="comment">//11</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="keyword">finally</span> 的 i --&gt; <span class="number">11</span></span><br><span class="line">main 的 i --&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>注意 mian 方法返回的 i 是 10，接受的是 try 里 return 的 i</p><h4 id="try…catch…finally-1"><a href="#try…catch…finally-1" class="headerlink" title="try…catch…finally"></a>try…catch…finally</h4><p>finally 语句块是一定会执行的，所以通常在程序中<br>为了保证某资源一定会释放，所以一般在 finally 语块中释放资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest06</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//必须在外面声明</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">"E:/theme-66.epf"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//避免空指针异常，保证资源一定会释放</span></span><br><span class="line">            <span class="keyword">if</span> (fis!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br></pre></td></tr></table></figure></p><p>输出结果为空，因为没有异常，在 finally 已经释放资源</p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>异常的完整应用，其中包含手动抛出异常<br>eg. 需求自定义注册“无效名字异常”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义一个异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IllegalNameException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;<span class="comment">//编译时异常</span></span><br><span class="line"><span class="comment">//public class IllegalNameException extends Exception&#123;//运行时异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义异常一般提供两个构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IllegalNameException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IllegalNameException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顾客相关的业务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供一个注册的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String name)</span> <span class="keyword">throws</span> IllegalNameException</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成注册</span></span><br><span class="line">        <span class="keyword">if</span> (name.length()&lt;<span class="number">6</span>)&#123;</span><br><span class="line">            <span class="comment">//异常</span></span><br><span class="line">            <span class="comment">//创建异常对象</span></span><br><span class="line">            <span class="comment">//IllegalNameException e = new IllegalNameException("用户名长度不能少于 6 位");</span></span><br><span class="line">            <span class="comment">//手动抛出异常</span></span><br><span class="line">            <span class="comment">//throw e;</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalNameException(<span class="string">"用户名长度不能少于 6 位"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果代码能执行到此处，证明用户名是合法的</span></span><br><span class="line">        System.out.println(<span class="string">"注册成功！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟注册</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入用户提供的用户名如下</span></span><br><span class="line">        String username = <span class="string">"wihie"</span>;</span><br><span class="line">        <span class="comment">//注册</span></span><br><span class="line">        CustomerService cs = <span class="keyword">new</span> CustomerService();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            cs.register(username);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IllegalNameException e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">用户名长度不能少于 <span class="number">6</span> 位</span><br></pre></td></tr></table></figure><h3 id="方法的重写与异常"><a href="#方法的重写与异常" class="headerlink" title="方法的重写与异常"></a>方法的重写与异常</h3><p>重写的方法不能比被重写的方法抛出更宽泛的异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子类永远无法抛出比父类更多的异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上编译不通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上程序编译通过</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 异常处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组</title>
      <link href="/2019/03/26/Java%E6%95%B0%E7%BB%84/"/>
      <url>/2019/03/26/Java%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>Java 提供了一个数据结构：数组，用于存储相同类型的元素的一个固定大小的连续集合。数组是用于存储数据的集合，但往往将数组认为是相同类型的变量的集合<br>数组是一种效率最高的存储和随机访问对象引用序列的方式，在性能要求较高的场景中优先考虑数组<br><a id="more"></a></p><h1 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h1><h2 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h2><p>首先必须声明数组变量，才能在程序中使用数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dateType[] arrayRefVar;</span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line"><span class="keyword">double</span>[] myList;</span><br></pre></td></tr></table></figure></p><h2 id="创建、处理数组"><a href="#创建、处理数组" class="headerlink" title="创建、处理数组"></a>创建、处理数组</h2><p>数量变量的声明和创建数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求数组的大小,数组是定长的，一旦初始化声明后是不可改变长度的</span></span><br><span class="line">arrayRefVar.length</span><br></pre></td></tr></table></figure></p><p>eg.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] myList = &#123;<span class="number">7.2</span>, <span class="number">8.3</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印所有数组元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myList.length; i++) &#123;</span><br><span class="line">            System.out.println(myList[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算所有元素的总和</span></span><br><span class="line">        <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; myList.length; i++) &#123;</span><br><span class="line">            total += myList[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(total);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找最大元素</span></span><br><span class="line">        <span class="keyword">double</span> max = myList[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; myList.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (myList[i] &gt; max) max = myList[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h2><p>虽然数组是定长的，一旦初始化声明后是不可改变长度，但是我们可以利用 List 集合 add 方法里面的扩容思路来模拟实现<br>思路：创建一个长度与原数组不同的新数组，让原数组变量指向新数组，实现长度可变<br>ArrayList：动态数组，Array 的复杂版本</p><ol><li><p>创建新数组，让原数组变量指向新数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day032602;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] src1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] src2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        src1 = src2;</span><br><span class="line">        src1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        src1[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        src1[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">        System.out.println(Arrays.toString(src1));<span class="comment">//把数组转化成字符串输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></li><li><p>使用 ArrayList 代替数组，通过泛型 ArrayList 可以储存不同类型的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day032602;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; a = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        a.add(<span class="number">1</span>);</span><br><span class="line">        a.add(<span class="number">2</span>);</span><br><span class="line">        a.add(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//输出数组元素数量</span></span><br><span class="line">        System.out.println(a.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="for-each-循环"><a href="#for-each-循环" class="headerlink" title="for-each 循环"></a>for-each 循环</h2><p>for-each 循环或者加强型循环，它能在不使用下标的情况下遍历数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法格式</span></span><br><span class="line"><span class="keyword">for</span>(type element: array)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>eg.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] myList = &#123;<span class="number">7.2</span>, <span class="number">8.3</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印所有数组元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> element: myList)&#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">7.2</span></span><br><span class="line"><span class="number">8.3</span></span><br><span class="line"><span class="number">2.0</span></span><br><span class="line"><span class="number">3.0</span></span><br></pre></td></tr></table></figure></p><h2 id="数组的查找"><a href="#数组的查找" class="headerlink" title="数组的查找"></a>数组的查找</h2><p>查找是在数组中寻找特定元素的过程<br>两种常用的方法：线性查找（linear searching）和二分查找（binary searching）</p><h3 id="线性查找法"><a href="#线性查找法" class="headerlink" title="线性查找法"></a>线性查找法</h3><p>线性查找法将要查找的关键字 key 与数组中的元素逐个进行比较。如果匹配成功，线性查找法则返回与关键字匹配的元素在数组中的下标；如果没有匹配成功，则返回 -1<br>eg.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">LinearSearch</span><span class="params">(<span class="keyword">int</span>[] list,<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; list.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key == list[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, -<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> number1 = LinearSearch(list, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> number2 = LinearSearch(list, <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">int</span> number3 = LinearSearch(list, -<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(number1);</span><br><span class="line">        System.out.println(number2);</span><br><span class="line">        System.out.println(number3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>线性查找法把关键字和数组中的每一个元素进行比较，效率不高</p><h3 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h3><p>使用二分查找法的前提条件是数组中的元素必须已经排好序，假设数组已经按升序排，二分查找法首先将关键字与数组的中间元素进行比较，考虑下面三种情况：</p><ul><li>如果关键字小于中间元素，只需要在数组的前一半元素中继续查找关键字</li><li>如果关键字等于中间元素，则匹配成功，查找结束</li><li>如果关键字大于中间元素，只需要在数组的后一半元素中继续查找关键字</li></ul><p>eg.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] list,<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = list.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//直到low &gt; high时还没找到关键字就结束查找，返回 -1</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(key &lt; list[mid])&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; list[mid])&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(key == list[mid])&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] list = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> number1 = binarySearch(list,<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">int</span> number2 = binarySearch(list,<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">int</span> number3 = binarySearch(list,<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(number1);</span><br><span class="line">        System.out.println(number2);</span><br><span class="line">        System.out.println(number3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure></p><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p>eg.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//升序排序</span></span><br><span class="line">        <span class="comment">//定义一个整型数组</span></span><br><span class="line">        <span class="keyword">int</span>[] scores = &#123; <span class="number">78</span>, <span class="number">93</span>, <span class="number">84</span>, <span class="number">64</span> &#125;;</span><br><span class="line">        <span class="comment">//使用 Arrays 类的 sort() 方法对数组进行升序排序</span></span><br><span class="line">        Arrays.sort(scores);</span><br><span class="line">        System.out.println(<span class="string">"升序排序后数组中元素的值："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(scores));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//倒序排序</span></span><br><span class="line">        <span class="comment">//这里必须把 int 类型写成 Integer 类型才能通过</span></span><br><span class="line">        Integer [] scores1 = &#123; <span class="number">78</span>, <span class="number">93</span>, <span class="number">84</span>, <span class="number">64</span> &#125;;</span><br><span class="line">        <span class="comment">//使用 Arrays 类的 sort() 方法对数组进行倒序排序</span></span><br><span class="line">        Arrays.sort(scores1,Collections.reverseOrder());</span><br><span class="line">        System.out.println(<span class="string">"倒序排序后数组中元素的值："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(scores1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">升序排序后数组中元素的值：</span><br><span class="line">[<span class="number">64</span>, <span class="number">78</span>, <span class="number">84</span>, <span class="number">93</span>]</span><br><span class="line">倒序排序后数组中元素的值：</span><br><span class="line">[<span class="number">93</span>, <span class="number">84</span>, <span class="number">78</span>, <span class="number">64</span>]</span><br></pre></td></tr></table></figure></p><h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h2><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的<br>导入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br></pre></td></tr></table></figure></p><ul><li>给数组赋值：通过 fill 方法</li><li>对数组排序：通过 sort 方法，按升序</li><li>比较数组：通过 equals 方法比较数组中元素值是否相等</li><li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用二分查找算法在给定数组中搜索给定值的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(Object[] a, Object key)</span></span></span><br><span class="line"><span class="function"><span class="comment">//导入包之后引用：</span></span></span><br><span class="line"><span class="function">Arrays.<span class="title">binarySearch</span><span class="params">(Object[] a, Object key)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果两个指定的 long 型数组彼此相等，则返回 true</span></span><br><span class="line"><span class="comment">//如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的</span></span><br><span class="line"><span class="comment">//则认为这两个数组是相等的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">long</span>[] a, <span class="keyword">long</span>[] a2)</span></span></span><br><span class="line"><span class="function"><span class="comment">//导入包之后引用：</span></span></span><br><span class="line"><span class="function">Arrays.<span class="title">equals</span><span class="params">(<span class="keyword">long</span>[] a, <span class="keyword">long</span>[] a2)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//填充数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//eg.</span></span></span><br><span class="line"><span class="function"><span class="keyword">import</span> java.util.Arrays</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] a = &#123; <span class="number">10</span>, <span class="number">20</span> , <span class="number">36</span>, <span class="number">50</span>&#125;;</span><br><span class="line">        <span class="comment">//填充 a[1] 到 a[3-1] 为 8 </span></span><br><span class="line">        Arrays.fill(a,<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        <span class="comment">//输出 [10, 8, 8, 50]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] a = &#123; <span class="number">10</span>, <span class="number">20</span> , <span class="number">36</span>, <span class="number">50</span>&#125;;</span><br><span class="line">        <span class="comment">//全部填充为8</span></span><br><span class="line">        Arrays.fill(a,<span class="number">8</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        <span class="comment">//输出 [8, 8, 8, 8]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h1><p>新建一个二维数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [][] a = &#123;&#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>&#125;,&#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//访问二维数组的长度</span></span><br><span class="line">        System.out.println(a[<span class="number">0</span>].length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印数组，for 循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; a.length ; row++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; a[row].length ; column++)&#123;</span><br><span class="line">                System.out.println(a[row][column] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="数组线性表-ArrayList-类"><a href="#数组线性表-ArrayList-类" class="headerlink" title="数组线性表 ArrayList 类"></a>数组线性表 ArrayList 类</h1><p>Java 提供 ArrayList 类来存储不限定个数的对象<br>优点：</p><ul><li>容量不固定（有一个较大的最大阈值）</li><li>有序的（与输入顺序一致）</li><li>元素可以为 null</li><li>效率高</li><li>占用空间更小</li></ul><p>ArrayList 中的一些方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList()                                 创建一个空的线性表</span><br><span class="line">add(o: Object): <span class="keyword">void</span>                        在这个线性表的末尾追加一个新元素 <span class="number">0</span></span><br><span class="line">add(index: <span class="keyword">int</span>, o:Object): <span class="keyword">void</span>             在这个线性表的特定下标处增加一个新元素 <span class="number">0</span></span><br><span class="line">clear(): <span class="keyword">void</span>                               从这个线性表中删除所有的元素</span><br><span class="line">contains(o:Object): <span class="keyword">boolean</span>                 如果这个线性表包含元素 <span class="number">0</span> 则返回 <span class="keyword">true</span></span><br><span class="line">get(index: <span class="keyword">int</span>): Object                     返回这个线性表在特定下标处的元素</span><br><span class="line">indexOf(o:Object): <span class="keyword">int</span>                      返回这个线性表中第一个匹配元素的下标</span><br><span class="line">isEmpty(): <span class="keyword">boolean</span>                          如果这个线性表不包含元素则返回 <span class="keyword">true</span></span><br><span class="line">lastIndexOf(o:Object): <span class="keyword">int</span>                  返回这个线性表中最后一个匹配元素的下标</span><br><span class="line">remove(o:Object): <span class="keyword">boolean</span>                   删除指定下标处的元素</span><br><span class="line">set(index: <span class="keyword">int</span>, o:Object): Object           设置在特定下标处的元素</span><br></pre></td></tr></table></figure></p><p>eg.使用 ArrayList 存储对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList cityList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        cityList.add(<span class="string">"Hongkong"</span>);</span><br><span class="line">        cityList.add(<span class="string">"London"</span>);</span><br><span class="line">        cityList.add(<span class="string">"Paris"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"数组大小： "</span> + cityList.size());</span><br><span class="line">        System.out.println(<span class="string">"HongKong 在数组里吗？ "</span> + cityList.contains(<span class="string">"Hongkong"</span>));</span><br><span class="line">        System.out.println(<span class="string">"HongKong 在数组的哪个位置： "</span> + cityList.indexOf(<span class="string">"Hongkong"</span>));</span><br><span class="line">        System.out.println(<span class="string">"这个数组是空的吗？ "</span> + cityList.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在数组第 2 的位置增加 Guangdong</span></span><br><span class="line">        cityList.add(<span class="number">2</span>,<span class="string">"Guangdong"</span>);</span><br><span class="line">        <span class="comment">//移除 London</span></span><br><span class="line">        cityList.remove(<span class="string">"London"</span>);</span><br><span class="line">        <span class="comment">//移除 Paris</span></span><br><span class="line">        cityList.remove(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以字符串形式输出数组</span></span><br><span class="line">        System.out.println(cityList.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//for 循环遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cityList.size() - <span class="number">1</span>; i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            System.out.println(cityList.get(i) + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">数组大小： <span class="number">3</span></span><br><span class="line">HongKong 在数组里吗？ <span class="keyword">true</span></span><br><span class="line">HongKong 在数组的哪个位置： <span class="number">0</span></span><br><span class="line">这个数组是空的吗？ <span class="keyword">false</span></span><br><span class="line">[Hongkong, Guangdong]</span><br><span class="line">Guangdong </span><br><span class="line">Hongkong</span><br></pre></td></tr></table></figure></p><h2 id="数组和-ArrayList-之间的异同"><a href="#数组和-ArrayList-之间的异同" class="headerlink" title="数组和 ArrayList 之间的异同"></a>数组和 ArrayList 之间的异同</h2><p>可以像使用数组一样使用 ArrayList 对象，但是两者还是有很多不同之处<br>一旦创建了一个数组，它的大小就确定下来了。可以使用方括号访问数组元素（eg. a[index]）。当创建 ArrayList 后，它的大小为 0 。如果元素不在线性表中，就不能使用 get 和 set 方法。向线性表中添加，插入和删除元素是比较容易的，而向数组中添加、插入和删除元素是比较复杂的。为了实现这些操作，必须编写代码操纵这个数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    操作                             数组                                  ArrayList</span><br><span class="line">创建数组/ArrayList          Object[] a = <span class="keyword">new</span> Objext[<span class="number">10</span>]         ArrayList list = <span class="keyword">new</span> ArrayList()</span><br><span class="line">引用元素                    a [index]                           list.get(index)</span><br><span class="line">更新元素                    a [index] = <span class="string">"Hongkong"</span>;             list.set(index,<span class="string">"Hongkong"</span>);</span><br><span class="line">返回大小                    a length                            list.size()</span><br><span class="line">添加一个新元素                                                  list.add(<span class="string">"Hongkong"</span>)</span><br><span class="line">插入一个新元素                                                  list.add(index,<span class="string">"Hongkong"</span>)</span><br><span class="line">删除一个元素                                                    list.remove(index);</span><br><span class="line">删除一个元素                                                    list.remove(Object)</span><br><span class="line">删除所有元素                                                    list.clear()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数组 </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解Java面对对象的三大特性--封装、继承、多态</title>
      <link href="/2019/03/25/%E7%90%86%E8%A7%A3Java%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7-%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81/"/>
      <url>/2019/03/25/%E7%90%86%E8%A7%A3Java%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7-%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>Java 面对对象的三大特征是：封装、继承、多态<br>继承是为多态的实现做准备</p><a id="more"></a><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别</p><h2 id="封装的目的"><a href="#封装的目的" class="headerlink" title="封装的目的"></a>封装的目的</h2><p>增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，一特定的访问权限来使用类的成员</p><h2 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h2><p>良好的封装能够减少耦合<br>类内部的结构可以自由修改<br>可以对成员进行更精确的控制<br>隐藏信息，实现细节</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率</p><h2 id="使用继承的场景"><a href="#使用继承的场景" class="headerlink" title="使用继承的场景"></a>使用继承的场景</h2><p>当两个类具有相同的特征（属性）和行为（方法）时，可以将相同的部分抽取出来放到一个类中作为父类，其它两个类继承这个父类</p><h2 id="使用继承的优点"><a href="#使用继承的优点" class="headerlink" title="使用继承的优点"></a>使用继承的优点</h2><p>子类拥有父类非 private 的属性和方法，但是不能继承构造器，构造器只能被调用 super();（注意 super(); 必须是构造方法中的第一条语句）<br>eg.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    A()&#123;</span><br><span class="line">        System.out.println(<span class="string">"star!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    B()&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//必须在第一行</span></span><br><span class="line">        System.out.println(<span class="string">"aaa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">star!!</span><br><span class="line">aaa</span><br></pre></td></tr></table></figure></p><p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展<br>子类可以用自己的方式实现父类的方法<br>实现代码共享，避免重复外，还可以使得修改扩展继承而来的实现比较简单</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>多态，是面向对象的程序设计语言最核心的特征。多态，意味着一个对象有着多重特征，可以在特定的情况下，表现不同的状态，从而对应着不同的属性和方法<br>即同一个事件发生在不同的对象上会产生不同的结果（同样是 Animal 的 voice()，但是 Cat/Dog 不同对象产生的 voice() 结果是不一样的）</p><h3 id="实现技术"><a href="#实现技术" class="headerlink" title="实现技术"></a>实现技术</h3><p>动态绑定，是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>消除类型之间的耦合关系<br>程序的可扩展性及可维护性增强</p><h3 id="多态的例子"><a href="#多态的例子" class="headerlink" title="多态的例子"></a>多态的例子</h3><p>举一个通俗易懂的：比如有动物（Animal）之类别（class），由动物继承出类别鸟（Bird）、类别兔子（Ribbit）和猫（Cat），它们对同一源自类别动物（父类别）之一信息有不同的响应，如类别动物有“移动（）”这个动作，而类别鸟会“飞（）”，类别兔子会“跳（）”，类别猫则会“跑（）”，这就是多态，即相同的消息给予不同的对象会引发不同的动作</p><h2 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h2><p>Java 中有两种形式可以实现多态：基于继承实现多态和基于接口实现多态</p><h3 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h3><p>1   要有继承关系        （继承）<br>2   子类要重写父类的方法 （重写）<br>3   父类引用指向子类对象 （向上转型）<br>只要满足了上述三个条件，我们才能够在同一继承结构中使用统一的逻辑实现代码处理不同的对象，达到执行不同的行为，即多态</p><h3 id="基于继承实现多态"><a href="#基于继承实现多态" class="headerlink" title="基于继承实现多态"></a>基于继承实现多态</h3><p>基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为</p><p>eg.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义超类 Car</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"汽车发动机启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义子类 XiaoHuangYa</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoHuangYa</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小黄鸭的 Audi-RS5 发动机启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义子类 TuoHai</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TuoHai</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拓海的 丰田AE86 发动机启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类 Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Car c1 = <span class="keyword">new</span> XiaoHuangYa();</span><br><span class="line">        Car c2 = <span class="keyword">new</span> TuoHai();</span><br><span class="line"></span><br><span class="line">        c1.start(); <span class="comment">//小黄鸭的 Audi-RS5 发动机启动</span></span><br><span class="line">        c2.start(); <span class="comment">//拓海的 丰田AE86 发动机启动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line">小黄鸭的 Audi-RS5 发动机启动</span><br><span class="line">拓海的 丰田AE86 发动机启动</span><br></pre></td></tr></table></figure></p><p>上述程序遵循的原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，在子类被覆盖的方法；当子类重写父类的方法被调用时，只有对象继承链中的最末端的方法才会被调用<br>若超类是一个抽象类的时候，抽象类的子类必须覆盖实现超类中的所有的抽象方法，否则子类必须被 abstract 修饰符修饰，但是被 abstract 修饰之后不能被实例化</p><h3 id="基于接口实现多态"><a href="#基于接口实现多态" class="headerlink" title="基于接口实现多态"></a>基于接口实现多态</h3><p>接口的灵活性就在于“规定一个类必须做什么，而不管你如何做”。我们可以定义一个接口类型的引用变量来引用实现接口的类的实例，当这个引用调用方法时，它会根据实际引用的类的实例来判断具体调用哪个方法，这和上述的超类对象引用访问子类对象的机制相似。<br>继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性</p><p>eg.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个退出系统的方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个类实现该接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerServiceImpl</span> <span class="keyword">implements</span> <span class="title">CustomerService</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对接口中的抽象方法进行实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"成功退出系统！"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要执行 CustomerServiceImpl 中的 logout 方法</span></span><br><span class="line"><span class="comment">//以下程序面向接口去调用</span></span><br><span class="line">CustomerService cs = <span class="keyword">new</span> CustomerServiceImpl(); <span class="comment">//多态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">cs.logout();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">成功退出系统！</span><br></pre></td></tr></table></figure></p><p>Java 在利用接口变量调用其实现类的对象的方法时，该方法必须已经在接口中被声明，而且在接口的实现类中该实现方法的类型和参数必须与接口中所定义的精确匹配</p><h4 id="继承链中的优先级"><a href="#继承链中的优先级" class="headerlink" title="继承链中的优先级"></a>继承链中的优先级</h4><p>继承链中对象方法的调用存在一个优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)<br>即先查 this 对象的父类，没有就重头再查参数的父类</p><p>eg. 优先级的体现</p><ol><li><p>新建一个 A.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(D obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"A adn D"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(A obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"A and A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建一个 B.java 继承 A.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(B obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"B and B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(A obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="string">"B and A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建一个 C.java 继承 B.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建一个 D.java 继承 B.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建一个 Tesy.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tesy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">        A a2 = <span class="keyword">new</span> B();</span><br><span class="line">        B b  = <span class="keyword">new</span> B();</span><br><span class="line">        C c  = <span class="keyword">new</span> C();</span><br><span class="line">        D d  = <span class="keyword">new</span> D();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"1--&gt; "</span> + a1.show(b));</span><br><span class="line">        System.out.println(<span class="string">"2--&gt; "</span> + a1.show(c));</span><br><span class="line">        System.out.println(<span class="string">"3--&gt; "</span> + a1.show(d));</span><br><span class="line">        System.out.println(<span class="string">"4--&gt; "</span> + a2.show(b));</span><br><span class="line">        System.out.println(<span class="string">"5--&gt; "</span> + a2.show(c));</span><br><span class="line">        System.out.println(<span class="string">"6--&gt; "</span> + a2.show(d));</span><br><span class="line">        System.out.println(<span class="string">"7--&gt; "</span> + b.show(b));</span><br><span class="line">        System.out.println(<span class="string">"8--&gt; "</span> + b.show(c));</span><br><span class="line">        System.out.println(<span class="string">"9--&gt; "</span> + b.show(d));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>--&gt; A and A</span><br><span class="line"><span class="number">2</span>--&gt; A and A</span><br><span class="line"><span class="number">3</span>--&gt; A adn D</span><br><span class="line"><span class="number">4</span>--&gt; B and A</span><br><span class="line"><span class="number">5</span>--&gt; B and A</span><br><span class="line"><span class="number">6</span>--&gt; A adn D</span><br><span class="line"><span class="number">7</span>--&gt; B and B</span><br><span class="line"><span class="number">8</span>--&gt; B and B</span><br><span class="line"><span class="number">9</span>--&gt; A adn D</span><br></pre></td></tr></table></figure></p><p>该多态经典例子来自：<a href="https://blog.csdn.net/thinkGhoster/article/details/2307001" target="_blank" rel="noopener">Csdn-例子</a></p><p>看完例子，加入一些自己的理解，通过例子，对继承链中的优先级进行分析</p><p>学习完多态对于 1 - 7 都是比较好理解的，继承链中的优先级较好地体现在 8 9</p><p>先对 8 进行分析：b.show(c)，b 是 B 类型的引用变量，所以 this 就代表了 B，b.show(c)，它在 B 类中发现没有找到，于是到 B 的超类中找 (super)，由于 B 的超类是 A，所以到 A 找，super.show(0)，它在 A 类中发现没找到，现在到第 3 级 –&gt; this.show((super)0)，C 的超类有 B、A ，所以 (super)0 为 B、A ，this 依然是 B，现在在 B 类中找到了 show(B obj)，因此最终会调用 B 类的 show(B obj)方法，结果是 “B and B”</p><p>再对 9 进行分析：b.show(d), b 是 B 类型的引用变量，所以 this 就代表了 B，b.show(d)，它在 B 类中发现没有找到，于是到 B 的超类中找 (super)，由于 B 的超类是 A，所以到 A 找，super.show(0)，现在在 A 类中找到了 show(D obj)，因此最终会调用 A 类的 show(D obj)方法，结果是 “A and D”</p><p>通过修改 B.java ，删去 show(B obj) 方法，进一步说明继承链中的优先级</p><p>修改 8.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(A obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="string">"B and A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再运行 Tsey.java 会发现 8 的结果变成 “B and A”<br>对 8 变化的结果进行分析：当第三步在 B 类中没有找到 this.show((super)0)，再到第 4 级 –&gt; super.show((super)O)，B 的超类为 A ，所以 super 为 A ，现在在 A 类中找到了 show(A obj)，由于 b 是 B 类型的引用，在 B 类中重写了 show(A obj)，因此最终会调用 B 类的 show(A obj) 方法，结果是 “B and A”</p><p>修改 8.java 再把重写的 show(A obj) 方法删去<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再运行 Tsey.java 会发现 8 的结果变成 “A and A”<br>对 8 变化的结果进行分析：因为在第 4 级 A 类中找到 show(A obj) 方法，虽然 b 是 B 类型的引用，但是 B 类继承 A 类之后并没有重写 show(A obj) 方法，因此最终会调用 A 类的 show(A obj) 方法，结果是 “A and A”</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 封装 </tag>
            
            <tag> 继承 </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类和对象</title>
      <link href="/2019/03/22/Java%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/03/22/Java%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>个人学习之后对于 Java 类和对象的理解</p><p>类是一个模板，它描述一类对象的行为和状态，从类到对象即为实例化，从对象到类为抽象</p><a id="more"></a><h1 id="Java-类"><a href="#Java-类" class="headerlink" title="Java 类"></a>Java 类</h1><p>Java 类分为外部类和内部类<br>类可以看成是创建 Java 对象的模板<br>eg. 创建一个狗的类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">  String breed;<span class="comment">//品种</span></span><br><span class="line"><span class="keyword">int</span> age;<span class="comment">//年龄</span></span><br><span class="line">String color;<span class="comment">//颜色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为该 Dog 类的方法</span></span><br><span class="line"><span class="comment">//叫</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">barking</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"小狗在叫"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//饿</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hungry</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"小狗饿了"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//睡觉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleeping</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"小狗在睡觉"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java-外部类"><a href="#Java-外部类" class="headerlink" title="Java 外部类"></a>Java 外部类</h2><p>外部类只有 public 和 default(缺省) 两种修饰<br>如果一个类声明的时候使用了 public class 进行了声明，则类名称必须与文件名称完全一致<br>如果一个类声明的时候使用了 class 进行了声明，则作为启动类的名称可以与文件名称不一致，但是执行的时候肯定执行的是生成后的名称<br>在一个 *.java 文件中，只能有一个 public class 的声明（公共接口），但是允许有多个 class 声明；public 类不是必须的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公开可访问，被 public 修饰的类可以被其他包访问</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同一个包内可访问，该类不能被其他包访问</span></span><br><span class="line"><span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java-内部类"><a href="#Java-内部类" class="headerlink" title="Java 内部类"></a>Java 内部类</h2><p>在外部类的内部再声明一个类则称为内部类，内部类有：静态内部类、成员内部类、局部内部类、匿名内部类<br>内部类均可结合变量进行理解</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类可以等同看作静态变量，可以用 public,protected,private 修饰<br>可以定义静态或者非静态的成员<br>静态内部类的作用是：可以访问外部类中私有的数据<br>看到带有 $ 符号的 .class 文件基本是内部类<br>静态内部类可以直接访问外部类的静态数据，无法直接访问成员<br>eg.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 关于静态内部类</span></span><br><span class="line"><span class="comment"> * 1、静态内部类可以等同看作静态变量</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 内部类重要的作用：可以访问外部类中私有的数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2、静态内部类可以直接访问外部类的静态数据，无法直接访问成员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态变量</span></span><br><span class="line"><span class="keyword">static</span> String s1 = <span class="string">"A"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String s2 = <span class="string">"B"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"static's m1 method execute!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"m2 method execute!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line"><span class="comment">//可以用访问控制权限的修饰符修饰</span></span><br><span class="line"><span class="comment">//public,protected,private,缺省</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(s1);</span><br><span class="line">m1();</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(s2);</span></span><br><span class="line"><span class="comment">//m2();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(s1);</span><br><span class="line">m1();</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(s2);</span></span><br><span class="line"><span class="comment">//m2();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行 m3</span></span><br><span class="line">OuterClass.InnerClass.m3();</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行 m4</span></span><br><span class="line">InnerClass inner = <span class="keyword">new</span> OuterClass.InnerClass();</span><br><span class="line">inner.m4();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类可以等同看作成员变量<br>区别于局部内部类的地方是定义在方法外<br>成员内部类中不能有静态声明<br>成员内部类可以访问外部类所有的数据<br>eg.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 关于成员内部类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1、成员内部类可以等同看作成员变量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2、成员内部类中不能有静态声明</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3、成员内部类可以访问外部类所有的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态变量</span></span><br><span class="line"><span class="keyword">static</span> String k1 = <span class="string">"A"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String k2 = <span class="string">"B"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">y1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"static's y1 method execute!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">y2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"y2 method execute!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员内部类</span></span><br><span class="line"><span class="comment">// 可以用访问控制权限的修饰符修饰</span></span><br><span class="line"><span class="comment">// public,protected,private,缺省</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public static void y3() &#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">y4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(k1);</span><br><span class="line">y1();</span><br><span class="line"></span><br><span class="line">System.out.println(k2);</span><br><span class="line">y2();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建外部类对象</span></span><br><span class="line"></span><br><span class="line">OuterClass02 oc = <span class="keyword">new</span> OuterClass02();</span><br><span class="line">InnerClass inner = oc.new InnerClass();</span><br><span class="line"></span><br><span class="line">inner.y4();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类等同于局部变量<br>区别于成员内部类的地方是定义在方法内<br>局部内部类不能有静态声明<br>重点：局部内部类在访问局部变量的时候，局部变量必须使用 final 修饰<br>eg.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 局部内部类等同于局部变量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 重点：局部内部类在访问局部变量的时候，局部变量必须使用 final 修饰</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//局部变量</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//局部内部类</span></span><br><span class="line"><span class="comment">//局部内部类不能用访问控制权限修饰符修饰</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部类不能有静态声明</span></span><br><span class="line"><span class="comment">//public static void m1() &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(i);<span class="comment">//10</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 m2</span></span><br><span class="line">InnerClass inner = <span class="keyword">new</span> InnerClass();</span><br><span class="line">inner.f2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">OuterClass03 oc = <span class="keyword">new</span> OuterClass03();</span><br><span class="line">oc.f1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名类不能使用任何关键字和访问控制符</p><p>eg.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匿名内部类：指的是类没有名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t</span><span class="params">(CustomerService cs)</span> </span>&#123;</span><br><span class="line">cs.logout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 t 方法</span></span><br><span class="line"><span class="comment">//t(new CustomerServiceImpl());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用匿名内部类的方式执行 t 方法</span></span><br><span class="line"><span class="comment">//整个这个 "new CustomerService()&#123;&#125;" 就是个匿名内部类</span></span><br><span class="line">t(<span class="keyword">new</span> CustomerService() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"系统已经安全退出！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名内部类的优点：少定义一个类</span></span><br><span class="line"><span class="comment">//缺点：无法重复使用！</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CustomerService</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//退出系统</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不使用匿名内部类的情况</span></span><br><span class="line"><span class="comment">//编写一个类实现 CustomerService 接口</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class CustomerServiceImpl implements CustomerService&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public void logout() &#123;</span></span><br><span class="line"><span class="comment">System.out.println("系统已经安全退出！");</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h3 id="局部、静态、成员内部类的访问区别"><a href="#局部、静态、成员内部类的访问区别" class="headerlink" title="局部、静态、成员内部类的访问区别"></a>局部、静态、成员内部类的访问区别</h3><p>eg. 局部内部类的访问<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问局部内部类必须先有外部类对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="comment">//局部内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;<span class="comment">//定义在方法内部</span></span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//访问局部内部类必须先有外部类对象</span></span><br><span class="line">Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">out.f(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>eg. 静态内部类的访问<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部类访问内部类的非静态成员：实例化内部类即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inner_f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> outer_f2&#123;</span><br><span class="line"><span class="comment">//访问</span></span><br><span class="line">Inner inn = <span class="keyword">new</span> Inner();</span><br><span class="line">inn.inner_f1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>eg. 成员内部类的访问<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">inner_f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//外部类的非静态方法访问成员内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outer_f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner inn = <span class="keyword">new</span> Inner();</span><br><span class="line">        inn.inner_f1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//外部类的静态方法访问成员内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outer_f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//建立外部类对象</span></span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        <span class="comment">//根据外部类对象建立内部类对象</span></span><br><span class="line">        Inner inn = out.new Inner();</span><br><span class="line">        <span class="comment">//访问内部类的方法</span></span><br><span class="line">        inn.inner_f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>面向对象三大特征：封装、继承、多态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 封装：问权限控制 public &gt; protected &gt; 缺省 &gt; private 内部类也是一种封装</span><br></pre></td></tr></table></figure></p><p>public                公开，任何位置都可以访问<br>protected            同包，子类<br>缺省                  同胞<br>private                私有，只能在本类中访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2. 继承：一般类只能单继承，内部类实现多继承，接口可以多继承</span><br><span class="line">3. 多态：编译时多态，体现在向上转型和向下转型，通过引用类型判断调用哪个方法（静态分派）。</span><br><span class="line">        运行时多态，体现在同名函数通过不同参数实现多种方法（动态分派）。</span><br></pre></td></tr></table></figure></p><p>对象具有状态和行为，从类到对象即为实例化<br>从类中创造对象：</p><ul><li>声明：声明一个对象，包括对象名称和对象类型</li><li>实例化：使用关键字 new 来创建一个对象</li><li>初始化：使用 new 创建对象时，会调用构造方法初始化对象; eg. Dog gg = new Dog();<br>eg. 下面创建一个名为 Puppy 的狗对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puppy</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="comment">//这个构造器仅有一个参数：name</span></span><br><span class="line">System.out.println(<span class="string">"小狗的名字是 : "</span> + name );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">// 下面的语句将创建一个Puppy对象</span></span><br><span class="line">Puppy myPuppy = <span class="keyword">new</span> Puppy( <span class="string">"tommy"</span> );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>实例化对象后访问实例变量和方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line">ObjectReference = <span class="keyword">new</span> Constructor();</span><br><span class="line"><span class="comment">//访问类中的变量</span></span><br><span class="line">ObjectReference.variableName;</span><br><span class="line"><span class="comment">//访问类中的方法</span></span><br><span class="line">ObjectReference.methodName();</span><br></pre></td></tr></table></figure></p><p>eg. 定义一个计算机类和学生类，让其中一个学生去使用其中的一台某品牌的某型号笔记本电脑<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需求：</span></span><br><span class="line"><span class="comment"> * 定义一个计算机类（电脑/笔记本）属性：</span></span><br><span class="line"><span class="comment"> * - 品牌</span></span><br><span class="line"><span class="comment"> * - 型号</span></span><br><span class="line"><span class="comment"> * - 颜色</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 定义一个学生类属性：</span></span><br><span class="line"><span class="comment"> * - 学号</span></span><br><span class="line"><span class="comment"> * - 姓名</span></span><br><span class="line"><span class="comment"> * - 学生有一台笔记本电脑</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请编写程序来表示以上的类，分别将类创建为对象</span></span><br><span class="line"><span class="comment"> * 对象数量不限，然后让其中的一个学生去使用其中的一台笔记本电脑</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 编译并运行，并且将整个执行过程采用图形的方式描述出来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOTest06</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Computer emt = <span class="keyword">new</span> Computer();</span><br><span class="line">emt.brand = <span class="string">"SummerCommpany"</span>;</span><br><span class="line">emt.number = <span class="string">"SUM-002"</span>;</span><br><span class="line"></span><br><span class="line">Stuu kmt = <span class="keyword">new</span> Stuu();</span><br><span class="line">kmt.no = <span class="number">6623798</span>;</span><br><span class="line">kmt.name = <span class="string">"WiHieree"</span>;</span><br><span class="line"></span><br><span class="line">emt.s = kmt;</span><br><span class="line">kmt.c = emt;</span><br><span class="line"></span><br><span class="line">System.out.println(kmt.name + <span class="string">" 使用的电脑是 "</span> + kmt.c.brand + <span class="string">" 旗下的 "</span> + kmt.c.number);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">String brand;</span><br><span class="line">String number;</span><br><span class="line">String col;</span><br><span class="line">Stuu s;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stuu</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> no;</span><br><span class="line">String name;</span><br><span class="line">Computer c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>所有属性私有化，使用 private 关键字进行修饰，private 表示私有的，修饰的所有数据,使得数据只能在本类访问<br>封装主要是因为 Java 有访问权限的控制 public &gt; protected &gt; package &gt; default &gt; private<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>封装可以保护类中的信息，只提供想要被外界访问的信息<br>对外提供简单的操作入口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 对外提供两个公开的方法，分别是 set 方法和 get 方法</span><br><span class="line"><span class="number">2</span>. 想修改 age 属性，调用 set 方法</span><br><span class="line">    命名规范：</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">3</span>. 想读取 age 属性，调用 get 方法</span><br><span class="line">    命名规范：</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>eg. 新建一个 User.java ，并进行封装保证输入年龄在合理范围内<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wihieree01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性私有化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">set 方法没有返回值，因为 set 方法只负责修改数据</span></span><br><span class="line"><span class="comment">public void setAge(int age) &#123;</span></span><br><span class="line"><span class="comment">age = age; // Java 有就近原则，这里其实并没有给 age 属性赋值，这里的 age 都是局部变量 age</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写业务逻辑代码进行安全控制</span></span><br><span class="line"><span class="comment">//age = a;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a &lt;<span class="number">0</span> || a &gt; <span class="number">150</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"对不起，您提供的年龄不合法"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序可以执行到这里，说明 a 年龄是合法的，则进行赋值运算</span></span><br><span class="line">age = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//getter</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>eg. 新建一个 UserTest.java 创建一个 User 对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wihieree01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 User 对象</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译报错，age 属性私有化，在外部程序中不能直接访问</span></span><br><span class="line"><span class="comment">//从此之后 age 属性非常安全，但是有点太安全了</span></span><br><span class="line"><span class="comment">//对于目前的程序来说，age 属性彻底在外部访问不到了</span></span><br><span class="line"><span class="comment">//System.out.println(user.age);</span></span><br><span class="line"><span class="comment">//在 User.Java 添加 setter and getter 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line"><span class="comment">//user.setAge(-100); //对不起，您提供的年龄不合法</span></span><br><span class="line">    user.setAge(<span class="number">23</span>); <span class="comment">// 23</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取</span></span><br><span class="line">System.out.println(user.getAge());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法的作用：创建对象和在创建对象的同时，初始化实例变量的内存空间<br>eg. 创建一个银行客户对象，查看户主名称，账号和余额</p><ol><li><p>创建一个 Account.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wihieree02;</span><br><span class="line"></span><br><span class="line"><span class="comment">//账户类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//户主</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//账号</span></span><br><span class="line"><span class="keyword">private</span> String actno;</span><br><span class="line"><span class="comment">//余额</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参数构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String name,String actno,<span class="keyword">double</span> balance)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.actno = actno;</span><br><span class="line"><span class="keyword">this</span>.balance = balance;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装 get / set</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getActno</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> actno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setActno</span><span class="params">(String actno)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.actno = actno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.balance = balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个 ConstructorTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wihieree02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorTest02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看访问的是哪个属性按 Ctrl + 鼠标移动到查看的元素上单击</span></span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">Account act1 = <span class="keyword">new</span> Account(<span class="string">"WiHieree"</span>,<span class="string">"SUM-0984"</span>,<span class="number">1980000.0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"户主："</span> + act1.getName());<span class="comment">//户主：WiHieree</span></span><br><span class="line">System.out.println(<span class="string">"账号："</span> + act1.getActno());<span class="comment">//账号：SUM-0984</span></span><br><span class="line">System.out.println(<span class="string">"余额："</span> + act1.getBalance());<span class="comment">//余额：1980000.0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承的基本作用是：代码复用，但是继承最重要的作用是：有了继承才有了以后方法的覆盖和多态机制<br>Java 中的继承只能单继承，但是可以通过内部类继承其他类来实现多继承<br>语法结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符列表] <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类名</span>&#123;<span class="comment">//关键字 extends</span></span><br><span class="line">类体 = 属性 + 方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有的不支持继承</span></span><br><span class="line"><span class="comment">// 构造方法不支持继承</span></span><br><span class="line"><span class="comment">// 其他数据都可以被继承</span></span><br></pre></td></tr></table></figure></p><p>虽然 java 语言当中只支持单继承，但是一个类也可以间接继承其它类，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C extends B&#123;</span><br><span class="line">&#125;</span><br><span class="line">B extends A&#123;</span><br><span class="line">&#125;</span><br><span class="line">A extends T&#123;</span><br><span class="line">&#125;</span><br><span class="line">// C 直接继承 B 类，但是 C 类间接继承 T、A类</span><br></pre></td></tr></table></figure></p><p>java 中假设一个类没有显示的继承任何类，该类默认继承 JavaSE 库当中提供的 java.lang.Object 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day1403;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsTest02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">C c = <span class="keyword">new</span> C();</span><br><span class="line"><span class="comment">//B 继承 A ，C 继承 B ，即 C 间接继承 A，所以 c. 可以访问 A 中的 doSome(); 方法</span></span><br><span class="line">c.doSome();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"do some!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法覆盖"><a href="#方法覆盖" class="headerlink" title="方法覆盖"></a>方法覆盖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">关于 java 语言当中方法的覆盖：</span><br><span class="line">1、方法覆盖又被称为方法重写，override/overwrite</span><br><span class="line"></span><br><span class="line">2、什么时候使用方法重写</span><br><span class="line">当父类中的方法已经无法满足当前子类的业务需求</span><br><span class="line">子类有必要将父类中继承过来的方法进行重新编写</span><br><span class="line">这个重新编写的过程称为方法重写/方法覆盖</span><br><span class="line"></span><br><span class="line">3、什么条件满足之后方法会发生重写呢 [代码满足什么条件之后，就构成方法的覆盖呢]</span><br><span class="line">方法重写发生在具有继承关系的父子类之间</span><br><span class="line">返回值类型相同，方法名相同，形参列表相同</span><br><span class="line">访问权限不能更低，可以更高</span><br><span class="line">抛出异常不能更多，可以更少[以后讲]</span><br><span class="line"></span><br><span class="line">4、建议方法重写的时候尽量复制粘贴，不要编写，容易出错，导致没有产生覆盖</span><br><span class="line"></span><br><span class="line">5、注意：</span><br><span class="line">私有方法不能继承，所以不能覆盖</span><br><span class="line">构造方法不能继承，所以不能覆盖</span><br><span class="line">静态方法不存在覆盖</span><br><span class="line">覆盖只针对方法，不谈属性</span><br></pre></td></tr></table></figure><p>eg.</p><ol><li><p>新建一个 Animal.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day1404;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动物类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动物都是可以移动的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"动物在移动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建一个 Bird.java 去继承 Animal ，此时鸟儿是在飞，要满足鸟儿飞就需要方法覆盖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day1404;</span><br><span class="line"></span><br><span class="line"><span class="comment">//飞禽类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法覆盖</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"鸟儿在飞行"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建一个 Cat.java 去继承 Animal ，此时猫应该是走猫步，满足这个条件需要方法覆盖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day1404;</span><br><span class="line"></span><br><span class="line"><span class="comment">//猫科类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"猫在走猫步"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>建一个测试 OverrideTest01.java </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideTest01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建动物对象</span></span><br><span class="line">Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">a.move();<span class="comment">//动物在移动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建猫科类动物对象</span></span><br><span class="line">Cat c = <span class="keyword">new</span> Cat();</span><br><span class="line">c.move();<span class="comment">//猫在走猫步</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建飞禽类动物对象</span></span><br><span class="line">Bird b = <span class="keyword">new</span> Bird();<span class="comment">//鸟儿在飞行</span></span><br><span class="line">b.move();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态语法机制，暂时参考上面的 Animal.java 和 Cat.java<br>使用多态语法机制：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal a1 = <span class="keyword">new</span> Cat(); </span><br><span class="line"><span class="comment">//向下类型转换   父类 --&gt; 子类</span></span><br><span class="line">Cat c1 = (Cat)a1;</span><br><span class="line"><span class="comment">//当调用的方法或者访问的属性是子类型中特有的，在父类型当中不存在，必须进行向下转型</span></span><br></pre></td></tr></table></figure></p><p>eg.</p><ol><li><p>修改 Cat.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day1405;</span><br><span class="line"></span><br><span class="line"><span class="comment">//猫类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写父类中继承过来的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//！！！super 关键字</span></span><br><span class="line"><span class="comment">//若重写后还是想要输出父类 Animal 的 move() 方法</span></span><br><span class="line"><span class="comment">//super.move();//动物在移动</span></span><br><span class="line">System.out.println(<span class="string">"猫在溜达溜达"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类对象特有的行为</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"猫抓老鼠！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改 Bird.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day1405;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鸟儿类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"鸟儿在飞翔"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Bird Fly"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建 Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day1405;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用多态语法机制</span></span><br><span class="line">Animal a1 = <span class="keyword">new</span> Cat();<span class="comment">//子类 --&gt; 父类称为向上转型</span></span><br><span class="line">a1.move(); <span class="comment">//猫在溜达溜达//结果主要看底层对象，底层对象是 Cat 调用的方法也是 Cat 对象的方法</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 需求：</span></span><br><span class="line"><span class="comment">* 假设想让以上的对象执行 catchMouse() 方法</span></span><br><span class="line"><span class="comment">* a2 是无法直接调用的，因为 a2 类型 Animal,Animal 中没有 catchMouse() 方法</span></span><br><span class="line"><span class="comment">* 我们可以将 a2 强制类型转换为 Cat 类型</span></span><br><span class="line"><span class="comment">* a2 的类型是 Animal（父类），转换成 Cat 类型（子类），被称为向下转型/downcasting/强制类型转换</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 注：向下转型也需要两种类型之间必须有继承关系。不然编译器报错，强制类型转换需要加强制类型转换符</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 什么时候需要使用向下转型呢</span></span><br><span class="line"><span class="comment">* 当调用的方法或者访问的属性是子类型中特有的，在父类型当中不存在，必须进行向下转型</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line">Cat c1 = (Cat)a1;</span><br><span class="line">c1.catchMouse();<span class="comment">//猫抓老鼠！</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* long x = 100L;</span></span><br><span class="line"><span class="comment">* int i = (int)i;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line">Animal a2 = <span class="keyword">new</span> Bird();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1、以下程序编译是没有问题的，因为编译器检查到 a2 的数据类型是 Animal，Animal 和 Cat 之间存在继承关系</span></span><br><span class="line"><span class="comment">*并且 Animal 是父类型，Cat 是子类型，父类型转换成子类型叫做向下转型，语法合格</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 2、程序虽然编译通过了，但是程序在运行阶段会出现异常，因为 JVM 堆内存当中真实存在的对象是 Bird 类型</span></span><br><span class="line"><span class="comment">*Bird 对象无法转换成 Cat 对象，因为两种类型之间不存在任何继承关系，此时出现了著名的异常：</span></span><br><span class="line"><span class="comment">* java.lang.ClassCastException</span></span><br><span class="line"><span class="comment">* 类型转换异常，这种异常总是在"向下转型"的时候会发生</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//Cat c2 = (Cat)a2; // Bird 和 Cat 不存在继承关系</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1、以上异常只有在强制类型转换的时候会发生，也就是说"向下转型"存在隐患(编译通过，但是运行错误)</span></span><br><span class="line"><span class="comment">* 2、向上转型只要编译通过，肯定可以运行  eg. Animal a = new Cat();</span></span><br><span class="line"><span class="comment">* 3、向下转型编译通过，运行可能错误   eg. Animal a2 = new Bird();Cat c2 = (Cat)a2;</span></span><br><span class="line"><span class="comment">* 4、怎么避免向下转型出现的 ClassCastException</span></span><br><span class="line"><span class="comment">* 使用 instanceof 运算符可以避免出现以上的异常</span></span><br><span class="line"><span class="comment">* 5、instanceof 运算符：</span></span><br><span class="line"><span class="comment">* 5.1、语法格式：</span></span><br><span class="line"><span class="comment">* (引用 instanceof 数据类型名)</span></span><br><span class="line"><span class="comment">* 5.2、以上运算符的执行结果类型是布尔类型，结果可能是 true/false</span></span><br><span class="line"><span class="comment">* 5.3、关于运算结果 true/false</span></span><br><span class="line"><span class="comment">* 假设：(a instanceof Animal)</span></span><br><span class="line"><span class="comment">* true ：</span></span><br><span class="line"><span class="comment">* a 这个引用指向的对象是一个 Animal 类型</span></span><br><span class="line"><span class="comment">* false：</span></span><br><span class="line"><span class="comment">* a 这个引用指向的对象不是一个 Animal 类型</span></span><br><span class="line"><span class="comment">* 6、Java 规范中要求：在进行强制类型转换之前，建议采用 instanceof 运算符进行判断，避免 ClassCastException 出现</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(a2 <span class="keyword">instanceof</span> Cat) &#123;<span class="comment">//a2 是一个 Cat 类型的对象</span></span><br><span class="line">Cat c2 = (Cat)a2;</span><br><span class="line">c2.catchMouse();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a2 <span class="keyword">instanceof</span> Bird) &#123;<span class="comment">//a3 是一个 Bird 类型的对象</span></span><br><span class="line">Bird b2 = (Bird)a2;</span><br><span class="line">b2.fly();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>eg. 多态在实际开发中的应用，主人喂养宠物</p><ol><li><p>创建一个 Master.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day1501;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Master</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Master 主人类面向的是一个抽象的 Pet，不再面向具体的宠物</span></span><br><span class="line"><span class="comment">//提倡：面向抽象编程，不要面向具体编程</span></span><br><span class="line"><span class="comment">//面向抽象编程的好处是，耦合度低，扩展力强</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feed</span><span class="params">(Pet pet)</span> </span>&#123;<span class="comment">// Pet pet 是一个父类型的引用</span></span><br><span class="line">pet.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个 Pet.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day1501;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 宠物</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有的宠物都可以吃东西</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个 Cat.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day1501;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 宠物小猫</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Pet</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小猫爱吃鱼</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"小猫在吃鱼！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个 Dog.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day1501;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 宠物小狗</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> SUMMER</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Pet</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"小狗正在啃骨头！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个 Test.java 用于测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.day1501;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 多态在实际开发中的作用，以下主人喂养宠物为例说明多态的作用：</span></span><br><span class="line"><span class="comment"> * 1、分析：主人喂养宠物这个场景要实现需要进行类型的抽象：</span></span><br><span class="line"><span class="comment"> * - 主人 [类]</span></span><br><span class="line"><span class="comment"> * - 主人可以喂养宠物，所以主人有喂养的这个动作</span></span><br><span class="line"><span class="comment"> * - 宠物 [类]</span></span><br><span class="line"><span class="comment"> * - 宠物可以吃东西，所以宠物有吃东西的这个动作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2、面向对象编程的核心：定义好类，然后将类实例化为对象，给一个环境驱使一下，</span></span><br><span class="line"><span class="comment"> *让各个对象之间协作起来形成一个系统</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3、多态的作用</span></span><br><span class="line"><span class="comment"> * 降低程序的耦合度，提高程序的扩展里</span></span><br><span class="line"><span class="comment"> * 能使用多态尽量使用多态</span></span><br><span class="line"><span class="comment"> * 父类型引用指向子类型对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 核心：面向抽象编程，尽量不要面向具体编程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建主人对象</span></span><br><span class="line">Master WiHieree = <span class="keyword">new</span> Master();</span><br><span class="line"><span class="comment">//创建猫对象</span></span><br><span class="line">Cat beer = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="comment">//主人喂养猫</span></span><br><span class="line">WiHieree.feed(beer);</span><br><span class="line"><span class="comment">//创建小狗对象</span></span><br><span class="line">Dog yt = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="comment">//主人喂小狗</span></span><br><span class="line">WiHieree.feed(yt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Method </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Method</title>
      <link href="/2019/03/21/Java%20Method/"/>
      <url>/2019/03/21/Java%20Method/</url>
      
        <content type="html"><![CDATA[<p>学习 Java 方法后的一些理解与总结</p><a id="more"></a><p>一个 Java 方法是为了执行某个操作的一些语句的组合，本质是一段代码片段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法定义在类体当中，在一个类当中可以定义多个方法</span><br><span class="line">方法编写的位置没有先后顺序，可以随意</span><br><span class="line">方法体当中不能再定义方法！！！！</span><br><span class="line">方法体由 java 语句构成，方法体当中的代码遵守自上而下的顺序依次执行</span><br></pre></td></tr></table></figure><h2 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stuAge</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">  <span class="comment">// method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>public static：修饰符</p><ul><li>可选项，不是必须的</li></ul></li><li><p>int：返回值类型</p><ul><li>返回值类型可以是 Java 任意一种类型，包括基本数据类型和所有的引用数据类型</li><li>也可能一个方法执行结束之后不返回任何数据，此时应使用 void 关键字</li><li>返回值类型不是 void 的时候，表示这个方法执行结束之后必须返回一个具体的值</li><li>return 值; //值的数据类型必须和方法的返回值一致，否则编译报错<br>eg. 拥有返回值类型的方法，定义方法计算两个 int 类型数据的商<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a / b;</span><br><span class="line">  <span class="comment">//已经执行 return 语句即结束当前方法</span></span><br><span class="line">  <span class="comment">//System.out.println("Wihieree");</span></span><br><span class="line">  <span class="comment">//编译报错，因为永远不会执行 sout</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当返回值为空的时候使用 return; 语句是为了结束当前方法</p></li><li><p>stuAge：方法名</p><ul><li>合法的标识符</li><li>见名知意</li><li>首字母要求小写，后面每个单词首字母大写<ol><li>stuAge   stuName   maxNumFuntion</li></ol></li></ul></li><li><p>a：形参（形式参数）</p><ul><li>可选项，不是必须</li><li>形参是局部变量</li><li>多个形参之间用 “逗号” 隔开，要求类型对应相同，类型不同的时候要求能够进行相应的自动类型转换<ol><li>int a,int b,int c</li></ol></li><li>形参中起决定性作用的是形参的数据类型，形参的名字就是局部变量的名字</li></ul></li><li><p>int a：参数列表</p><ul><li>方法再调用的时候，实际给这个方法传递的真实数据被称为：实际参数，简称实参</li><li>实参列表和形参列表必须满足<ol><li>数量相同</li><li>类型对应相同<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个 sum 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="comment">//int a,int b 是形参列表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法调用</span></span><br><span class="line"><span class="comment">//sum("abc","def"); //编译报错</span></span><br><span class="line">sum(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ol><p>eg. 定义一个 max() 方法，接受 num1 和 num2 两个参数并返回两者之间的最大值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxFunt</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> max;</span><br><span class="line">     <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">        max = num1;</span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        max = num2;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> max;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法只定义不去调用时不会执行的，只有在调用的时候才会执行</p><p>语法规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;方法的修饰符列表当中有 static &gt;</span><br><span class="line">类名.方法名(实参列表)；这是一条 java 语句，表示调用某个类的某个方法，传递这样的实参</span><br></pre></td></tr></table></figure></p><p>eg.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public 表示公开的</span></span><br><span class="line"><span class="comment">//class 表示定义类</span></span><br><span class="line"><span class="comment">// MethodTest03 是一个类名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodTest03</span> </span>&#123;</span><br><span class="line">    <span class="comment">//表示定义一个公开的类 MethodTest03，由于是公开的类，所以源文件名必须为 MethodTest03</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//类体</span></span><br><span class="line">    <span class="comment">//类体中不能直接编写 java 语句，除声明变量之外</span></span><br><span class="line">    <span class="comment">//方法出现在类体当中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="comment">//public 表示公开的</span></span><br><span class="line">    <span class="comment">//static 表示静态的</span></span><br><span class="line">    <span class="comment">//void 表示方法执行结束之后不返回任何数据</span></span><br><span class="line">    <span class="comment">//main 是方法名:主方法</span></span><br><span class="line">    <span class="comment">//(String[] args)：形式参数列表，其中String[]是一种引用数据类型，args 是一个局部变量的变量名</span></span><br><span class="line">    <span class="comment">//以下只有 args 这个局部变量的变量名是随意的</span></span><br><span class="line">    <span class="comment">//主方法就需要这样固定编写，这是程序的入口（SUN 规定的，必须这样写）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里的程序是一定会执行的</span></span><br><span class="line">        <span class="comment">//main 方法是 JVM 负责调用的，是一个入口位置</span></span><br><span class="line">        <span class="comment">//从这里作为起点开始执行程序</span></span><br><span class="line">        <span class="comment">//在这里调用其它方法</span></span><br><span class="line">        <span class="comment">//调用 MethodTest03 的 sum 方法，传递两个实参</span></span><br><span class="line">        MethodTest03.sum(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//实参</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//一个方法可以被重复使用，重复调用</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">300</span>;</span><br><span class="line">        MethodTest03.sum(a,<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义方法：不是程序的入口</span></span><br><span class="line">    <span class="comment">//方法作用：计算两个 int 类型数据的和，不要求返回结果，但是要求将结果直接输出到控制台</span></span><br><span class="line">    <span class="comment">//修饰符列表：public static</span></span><br><span class="line">    <span class="comment">//返回值类型：void</span></span><br><span class="line">    <span class="comment">//方法名：sum</span></span><br><span class="line">    <span class="comment">//形式参数列表：（int x,int y）</span></span><br><span class="line">    <span class="comment">//方法体：主要任务是求和之后输出计算结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;<span class="comment">//形参</span></span><br><span class="line">        System.out.println(i + <span class="string">" + "</span> + j + <span class="string">" = "</span> + (i + j));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参数的值传递"><a href="#参数的值传递" class="headerlink" title="参数的值传递"></a>参数的值传递</h2><p>在调用函数时参数是必须被传递的，并且他们的次序必须和他们创建时的参数次序是一样的，参数可以通过值或引用来传递<br>eg. 通过值来传递参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanShuTest01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">add(i);</span><br><span class="line">System.out.println(<span class="string">"main --&gt;&gt; "</span> + i); <span class="comment">// 10 这里的值是 main 方法里的 i 的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">i++;</span><br><span class="line">System.out.println(<span class="string">"add --&gt;&gt; "</span> + i); <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>eg. 通过值来传递参数，当传递的是内存地址的时候<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanShuTest02</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">User1 u = <span class="keyword">new</span> User1(<span class="number">20</span>);</span><br><span class="line">add(u);</span><br><span class="line">System.out.println(<span class="string">"main --&gt;&gt; "</span> + u.age);<span class="comment">//21</span></span><br><span class="line">    <span class="comment">//因为这里的 u  指向的 User1 对象的 age 值在 add 方法</span></span><br><span class="line">    <span class="comment">//里修改成了 21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User1 u 形参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(User1 u)</span> </span>&#123;</span><br><span class="line">u.age++;</span><br><span class="line">System.out.println(<span class="string">"add --&gt;&gt; "</span> + u.age); <span class="comment">//21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User1</span></span>&#123;</span><br><span class="line"><span class="comment">//实例变量</span></span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User1</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">age = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="方法重载-overload"><a href="#方法重载-overload" class="headerlink" title="方法重载 overload"></a>方法重载 overload</h2><p>当一个方法有两个或者更多的方法，他们的名字一样但是参数不同时，就叫做方法的重载<br>它与覆盖是不同的，覆盖是指方法具有相同的名字，类型以及参数的个数<br>方法重载的优点：</p><ul><li>程序员调用方法的时候，比较方便，虽然调用的是不同的方法，但是就感觉在调用同一个方法，不需要记忆更多的方法名</li></ul><p>方法重载的条件：</p><ul><li>在同一个类当中</li><li>方法名相同</li><li>参数列表不同：数量、顺序、类型不同</li><li>方法重载和方法名 + 参数列表有关系</li><li>方法重载和返回值类型、修饰符列表无关<br>eg. 定义一个计算两个 int 类型、long 类型、double 类型 数据的和的方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverloadTest01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(sum(<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">//3</span></span><br><span class="line">        System.out.println(sum(<span class="number">1.3</span>,<span class="number">2.5</span>)); <span class="comment">//3.8</span></span><br><span class="line">        System.out.println(sum(<span class="number">10L</span>,<span class="number">20L</span>)); <span class="comment">//30</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法递归"><a href="#方法递归" class="headerlink" title="方法递归"></a>方法递归</h2><p>方法递归即为方法自身调用自身<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a()&#123;</span><br><span class="line">  a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>递归是很耗费栈内存的，递归算法可以不用的时候尽量别用<br>递归必须有结束条件，没有结束条件一定会发生栈溢出错误<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionTest01</span> </span>&#123;</span><br><span class="line">    <span class="comment">//主方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//调用 doSome 方法</span></span><br><span class="line">       doSome();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// doSome 会被重复调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"doSome begin"</span>);</span><br><span class="line">        doSome();<span class="comment">//这行代码不结束，下一行程序是无法运行的</span></span><br><span class="line">        System.out.println(<span class="string">"doSome over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>递归即使有了结束条件，即使结束条件是正确的，也可能会发生栈内存溢出错误，因为递归太深了<br>主要应用为目录拷贝<br>eg. 使用递归计算 1~N 的求和<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionTest03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1~4 的和</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> retValue = sum(n);</span><br><span class="line">        System.out.println(retValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 4 + 3 + 2 + 1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + sum(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="构造方法（构造函数-构造器-Constructor）"><a href="#构造方法（构造函数-构造器-Constructor）" class="headerlink" title="构造方法（构造函数 / 构造器 / Constructor）"></a>构造方法（构造函数 / 构造器 / Constructor）</h2><p>构造方法的作用：构造方法存在的意义是通过构造方法的调用，可以创建对象<br>当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值<br>成员变量之实例变量，属于对象级别的变量，这种变量必须先有对象才能有实例变量<br>实例变量没有手动赋值的时候，系统默认赋值，在构造方法执行过程中完成的赋值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">构造方法语法结构：</span><br><span class="line">[修饰符列表]构造方法名(形式参数列表)&#123;</span><br><span class="line">  构造方法体;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虽然构造方法语法没有返回值类型，但是构造方法执行之后有返回值</span></span><br><span class="line"></span><br><span class="line">普通方法的语法结构：</span><br><span class="line">[修饰符列表]返回值类型 方法名(形式参数列表)&#123;</span><br><span class="line">  方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于构造方法来说，”返回值类型”不需要指定，并且也不能写 void, 只要写上 void，那么这个方法就是普通方法<br>通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象<br>当一个类中没有定义任何构造方法的话，系统默认给该类提供一个无参数的构造方法，这个构造方法被称为缺省构造器<br>当一个类显示的将构造方法定义出来了，那么系统则不再默认为这个类提供缺省构造器；建议开发中手动的为当前类提供无参数构造方法<br>构造方法支持重载机制</p><p>在 Java 类和对象的封装中进行补充说明</p><h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. static 译为 静态的</span><br><span class="line">2. static 修饰的方法是静态方法</span><br><span class="line">3. static 修饰的变量是静态变量</span><br><span class="line">4. 所有 static 修饰的元素都称为静态的，都可以使用&quot;类名.&quot;的方式访问，</span><br><span class="line">        当然也可以用&quot;引用.&quot;的方式访问（但是不建议）</span><br></pre></td></tr></table></figure><p>方法定义为静态的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 方法描述的是动作，当所有的对象执行这个动作的时候，最终产生影响是一样的，那么这个动作已经不再属于某一对象动作了，可以将这个动作提升为类级别的动作，模板级别的动作</span><br><span class="line">2. 静态方法中无法直接访问实例变量和实例方法</span><br><span class="line">3. 大多数方法都定义为实例方法，一般一个行为或者一个动作在发生的时候，都需要对象的参与，但是也有例外，例如：大多数&quot;工具类&quot;中的方法都是静态方法，因为工具类就是方便编程，为了方便方法的调用，自然不需要 new 对象是最好的</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Method </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
