{"meta":{"title":"WiyeeLu","subtitle":"卢夏天","description":"on my way to the topp.","author":"WiyeeLu","url":"https://wiyeelu.github.io","root":"/"},"pages":[],"posts":[{"title":"Git 简单指导","slug":"Git","date":"2019-04-01T02:01:39.000Z","updated":"2019-06-21T00:58:04.000Z","comments":true,"path":"2019/04/01/Git/","link":"","permalink":"https://wiyeelu.github.io/2019/04/01/Git/","excerpt":"Git 是目前世界上最先进的分布式版本控制系统","text":"Git 是目前世界上最先进的分布式版本控制系统 版本控制系统版本控制系统是任何能让你了解到一个文件的历史，以及它的发展过程的系统这样，使用版本控制系统就可以让自己和他人协作的时候了解修改了什么，在什么时候修改等 集中式版本控制系统 / 分布式版本控制系统集中式版本控制系统集中式版本控制系统，版本库是集中存放在中央服务器，需要进行操作的时候，需要先从中央服务器获取最新版本到本地的电脑再进行操作，操作完毕需要把自己修改完的版本推送到中央服务器123缺点：必须要进行联网才可以工作对于网络的带宽和速度要求较高 分布式版本控制系统分布式版本控制系统与集中式版本控制系统最大的区别是分布式版本控制系统根本没有“中央服务器” 每个人的电脑上都是一个完整的版本库这样工作的时候就不需要进行联网了，例如两个人都对同一个项目进行了修改，只需要把修改后的版本推送给对方就可以看到对方修改的内容（只是举例，很少这样操作） 分布式版本控制系统的安全性能也更高，因为完整的版本库都存在每个人的电脑，某一个人的电脑坏了，不影响整体，可以从任一个人的电脑是进行拷贝，如果是集中式版本控制系统的中央服务器要是出了问题，所有人都工作不了 分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已 Git 准备工作123git config --global user.name &quot;Your Name&quot; //namegit config --global user.email &quot;email@example.com&quot; //emailssh-keygen -t rsa -C &quot;youremail@example.com&quot; //SSH Key SSH Key 存在电脑用户目录下的 .ssh ，id_rsa.pub(公钥) 创建版本库 repository即仓库，一个目录，里面所有的文件都被 Git 管理，每个文件的修改、删除等任何操作 Git 都可以跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原” 创建一个版本库 12mkdir gitTest //创建文件夹cd gtiTest //切换到 gitLearn 目录 通过以下命令把这个目录变成 Git 管理的仓库 1git init Windows:1ls -ah 可以看到提示信息，多出了一个 . git 目录，这个目录是用来跟踪管理版本库的，切勿随意改动 把文件添加到版本库要使用版本控制系统，文件要以纯文本方式编写文件，因为所有的版本控制系统，只能跟踪文本文件的改动，详细到哪一行修改了哪一个字，但是图片和视频等二进制文件，虽然也可以用版本控制系统管理，但是不能跟踪文件的变动，即到底改了什么，版本控制系统不知道 在目录下新建一个 wihieree.txt 文本 使用 git 把文件添加到仓库12git add wihieree.txtgit commit -m &quot;add wihieree.txt&quot; add：提出更改（把它们添加到暂存区）commit：实际提交改动，执行完毕后改动提交到 HEAD ，但是还没到远端仓库 查看仓库当前状态修改 wihieree.txt 文件，添加 Wihieree gogogo!! 后运行1git status 该命令是让我们查看当前仓库的状态：由输出信息可以得知当前仓库的状态，wihieree.txt 被修改过，但是该修改还没有被提交如果想进一步查看修改了什么就可以使用1git diff 从输出可以得知我们在第 1 行增加了一句 wihieree gogogo!!提交修改和文件12git add wihieree.txtgit commit -m &quot;wihieree gogogo!!&quot; log 查看日志查看日志，可以让我们看到版本的历史记录，知道什么时候哪个版本作了什么修改1git log 可以看到有 2 次提交，最新的一次 wihieree gogogogit add wihieree.txt最早的一次是 add wihieree.txt Apr 2 09:39:01 2019log如果想了解本地仓库的历史记录1git log 可以添加一些参数来修改他的输出，从而得到自己想要的结果: 只看某一个人的提交记录 1git log --author=bob 一个压缩后的每一条提交记录只占一行的输出 1git log --pretty=oneline 通过 ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签 1git log --graph --oneline --decorate --all 看看哪些文件改变了 1git log --name-status 更多参数参考1git log --help 版本退回HEAD 表示当前版本，上一个版本是 HEAD^ ,上上个版本是 HEAD^^ ，上 20 个版本 HEAD~20 ,以此类推退回上上个版本，再进行查看 wihieree.txt12git reset --hard HEAD^cat wihieree.txt 可以看到版本被退回， wihieree gogogo!! 不见了若想退回最新的版本，可以回滚找到最新版本的 HEAD，例如我这里是 37c541git reset --hard 37c54 这样就可以恢复到最新的版本git reset 既可以回退版本，也可以把暂存区的修改回退到工作区使用 git reflog 命令可以查看输入的每一条命令，这样就可以找到以前版本的 HEAD 使用上面的办法进行回退1git reflog 当在工作区把某个文件修改错误，想丢弃工作区的修改时，使用 1git checkout -- &lt;file&gt; 如上修改错误还进行 git add 提交到了暂存区，想丢弃修改时，使用 12git reset HEAD &lt;file&gt;git checkout -- &lt;file&gt; hard/mixed/soft12345hard：回退一个版本,清空暂存区,将已提交的内容的版本恢复到本地,本地的文件也将被恢复的版本替换mixed(默认)：回退一个版本,且会将暂存区的内容和本地已提交的内容全部恢复到未暂存的状态 不影响原来本地文件(未提交的也不受影响) soft: 回退一个版本,不清空暂存区,将已提交的内容恢复到暂存区 不影响原来本地的文件(未提交的也不受影响) Git 工作区、暂存区、版本库之间的关系如上图所示如想进一步了解工作区、暂存区、版本库之间的关系可以点击此处hard/mixed/soft 区别深解可以点击此处 删除文件新建一个 test.txt ,并提交，然后对它进行删除1rm test.txt 再查看仓库状态1git status 这时候就会提示你哪些文件被删除了此时可以选择 继续删除文件 或者 从版本库里恢复最新版本的文件（以前版本的找不到，只可以恢复最新版本） 继续删除 1git rm test.txt 删错了，想恢复 1git checkout -- test.txt 远程仓库远程仓库是 Git 的杀手锏之一 远程仓库实际应用用一台电脑充当服务器，全天候开机，其他人都从这个服务器仓库克隆一份到自己本地的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交 Github 营运而生GitHub 是通过 Git 进行版本控制的软件源代码托管服务，只需要注册一个 GitHub 账号，就可以免费获得 Git 远程仓库！！该博客也是使用 Github 进行搭建注册完账号，网上寻找添加 SSH Key 的教程，就可以把本地 Git 仓库传输到 Github 仓库若有在不同的电脑上进行提交的需求，也可以把那台电脑的 SHH Key 添加到 Github，这样每台电脑都可以把本地 Git 仓库推送到 Github 仓库上 推送本地 Git 仓库到 Github 仓库在 Github 网站上新建一个 repo ，再把本地 Git 仓库关联到 Github 仓库1git remote add origin git@server-name:path/repo-name.git 关联后，推送 master 分支的所有内容（第一次）1git push -u origin master 后续提交新内容1git push origin master 这就体现了分布式版本系统的好处，本地工作根本和远程库没关系，没有网络也可以工作，只要在有网络的时候推送到远程库就可以了 从远程库克隆首先在 Github 新建一个 repo，300498-Stock-analysis克隆一个本地库 git clone1git clone git@github.com:WiyeeLu/300498-Stock-analysis.git Git 支持多种协议，包括 https ，但是通过 ssh 支持的原生 git 协议速度最快 分支管理分支可以理解为漫威的平行宇宙，我现在学 Java ，另一个平行宇宙的我在学 Python，这时的两个我互不干扰，不过在某个时间点，两个平行宇宙合并了，那时候的我就学会了 Java 又学会了 Python分支是用来将特性开发绝缘开来的。在创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上HEAD 严格来说不是指向提交，而是指向 master，master 才是指向提交的，所以 HEAD 指向的就是当前分支 创建分支创建 dev 分支1git checkout -b dev 使用 git branch 查看当前分支123E:\\gitLearn&gt;git branch* dev master 前面带有 * 号的表示当前分支在 wihieree.txt 上加上一行 lalala dev进行提交：12git add wihieree.txtgit commit -m &quot;add branch dev&quot; 若工作完成，切换回 master 分支1git checkout master 把 dev 分支的工作成果合并到 master 分支上1git merge dev 合并完成就可以删除 dev 分支1git branch -d dev 删除后可查看 branch1git branch 查看是否只剩 master 分支 解决冲突当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成从远程分支抓取最新的提交（更新你的本地仓库至最新改动）1git pull 建立本地分支与远程分支的连接1git branch --set-upstream dev origin/dev //dev 为分支名 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交用 git log –graph 命令可以看到分支合并图 分支管理策略Git 分支十分强大，在团队开发中应该充分应用。合并分支时，加上 –no-ff 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 fast forward 合并就看不出来曾经做过合并 BUG 分支修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场 git stash 一下，然后去修复 bug，修复后，再 git stash pop ，回到工作现场 Feature 分支开发一个新feature，最好新建一个分支1git checkout -b feature-vulcan 如果要丢弃一个没有被合并过的分支，可以通过 git branch -D 强行删除 多人协作（推送）查看远程库信息，使用1git remote -v 本地新建的分支如果不推送到远程，对其他人就是不可见的从本地推送分支，使用 git push origin branch-name ，如果推送失败，先用 git pull 抓取远程的新提交；在本地创建和远程分支对应的分支，使用 git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致建立本地分支和远程分支的关联，使用 git branch –set-upstream branch-name origin/branch-name；从远程抓取分支，使用 git pull，如果有冲突，要先处理冲突 Rebaserebase 操作可以把本地未 push 的分叉提交历史整理成直线rebase 的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比 标签管理发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑在一起 ####新建标签新建一个标签，默认为HEAD，也可以指定一个commit id1git tag &lt;tagname&gt; 指定标签信息1git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot; 查看所有标签1git tag 替换本地改动若操作失误，可以使用下面的命令替换掉本地改动1git checkout -- &lt;filename&gt; 此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件已添加到暂存区的改动以及新文件都不会受到影响 假如想丢弃在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将本地主分支指向它12git fetch origingit reset --hard origin/master Git 常用命令123456789101112131415161718192021222324252627282930313233343536373839404142mkdir //创建新目录git init //初始化一个 Git 仓库git add &lt;fileName&gt; //提交修改，可提交多次，把文件添加到暂存区git commit -m &lt;message&gt; //提交所有文件，把暂存区的所有内容提交到当前分支git status //查看仓库当前的状态git log //查看日志，什么时候修改了什么cat &lt;file&gt; //查看文件内容git reset --hard commit_id //可以在不同的版本间恢复git reflog //查看命令历史，以便要回到未来的某一个版本git diff HEAD -- wihieree.txt //查看工作区和版本库里面最新版本的区别git checkout -- wihieree.txt //把 wihieree.txt 文件在工作区的修改全部撤销，即回到最近一次 git commit 或 git add 时的状态git reset HEAD &lt;file&gt; //在 commit 之前，可以使用这个命令把暂存区的修改撤销掉，重新放回工作区git rm &lt;file&gt; //删除一个文件git checkout -- &lt;file&gt; //删错了文件，只要版本库里还有，就可以使用该命令恢复版本库里的最新版本git remote add origin git@server-name:path/repo-name.git //把本地 Git 仓库关联到 Github 仓库 eg. git remote add origin git@github.com:WiyeeLu/Wens-Stock-analysis.gitgit clone username@host:/path/to/repository //把 GitHub 仓库克隆到本地git push -u origin master //推送 master 分支的所有内容（第一次）git push origin master //后续提交新内容git branch //查看分支git branch &lt;name&gt; //创建分支git checkout &lt;name&gt; //切换分支git checkout -b &lt;name&gt; //创建 + 切换分支git merge &lt;name&gt; //合并某分支到当前分支git branch -d &lt;name&gt; //删除分支git log --graph //查看分支合并图git merge --no-ff -m \"merge with no-ff\" dev //用普通模式合并，合并后的历史有分支git stash //把当前工作现场“存储”起来git stash pop //回到工作现场git remote -v //查看远程库信息git push origin branch-name //从本地推送分支git pull //抓取远程的新提交（更新你的本地仓库至最新改动）git checkout -b branch-name origin/branch-name //本地创建和远程分支对应的分支git branch --set-upstream branch-name origin/branch-name //建立本地分支和远程分支的关联git rebase //可以把本地未 push 的分叉提交历史整理成直线git tag &lt;tagname&gt; //用于新建一个标签，默认为HEAD，也可以指定一个commit idgit tag -a &lt;tagname&gt; -m \"blablabla...\" //可以指定标签信息git tag //可以查看所有标签git push origin &lt;tagname&gt; //可以推送一个本地标签git push origin --tags //可以推送全部未推送过的本地标签git tag -d &lt;tagname&gt; //可以删除一个本地标签git push origin :refs/tags/&lt;tagname&gt; //可以删除一个远程标签","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://wiyeelu.github.io/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://wiyeelu.github.io/tags/Github/"}]},{"title":"Java图形用户界面基础","slug":"Java图形用户界面基础","date":"2019-03-31T05:32:17.000Z","updated":"2019-06-21T00:58:06.000Z","comments":true,"path":"2019/03/31/Java图形用户界面基础/","link":"","permalink":"https://wiyeelu.github.io/2019/03/31/Java图形用户界面基础/","excerpt":"为 Java GUI 程序设计而设计的 API 是应用面向对象原理的绝佳范例GUI 全称是 Graphical User Interface，简单的说是图形用户界面GUI 只有在桌面操作系统中才存在","text":"为 Java GUI 程序设计而设计的 API 是应用面向对象原理的绝佳范例GUI 全称是 Graphical User Interface，简单的说是图形用户界面GUI 只有在桌面操作系统中才存在 Swing 和 AWT不依赖于自己 GUI 的 Swing 组件称为轻量级组件（即对系统依赖性较弱），而 AWT 组件称为重量级组件（对系统依赖性较强）AWT 用户界面组件终究是要退出历史舞台，但是 Swing 组件不能取代 AWT 中的全部类，只能替代 AWT GUI 的组件类，AWT 辅助类在 GUI 程序设计中仍然很有用 AWT 缺点AWT 组件最大的缺陷就是它依赖于操作系统，也就是说 AWT 程序运行在不同的操作系统上会有不同的外观和行为，这和 Java 的平台无关性是不符合的 Swing 优点Swing 组件是在 AWT 组件上发展而来的轻量级组件，与 AWT 相比不但改进了用户界面，而且所需的系统资源更少Swing 是纯 Java 组件，使得应用程序在不同的平台上运行时具有相同的外观和相同的行为 Java GUI APIGUI API 包含的类可以分成三个组：组件类（component class）、容器类（container class）和辅助类（helper class）组件类是用来创建用户界面的，例如：JButton、JLable 和 JTextField容器类是用来包含其他组件的，例如：JFrame、JPanel 和 JApplet辅助类是用来支持 GUI 组件，例如：Graphics、Color、Font、FontMetrics 和 Dimension 组件类Component 类的实例可以显示在屏幕上，是包括容器类的所有用户界面类的根类JComponent 类是所有轻量级 Swing 组件类的根类Component 类和 JComponent 类都是抽象类 容器类一个 Container 的实例可以包含 Component 实例容器类是用于盛装其他 GUI 组件的 GUI 组件 123456 容器类 说 明java.awt.Container 用于对组件分组。框架 Frame、面板 Panel 和 applet 都是它的子类java.swing.JFrame 一个不能包含在另一个窗口中的窗口。在 Java GUI 应用程序中，它用于存放其他 Swing 用户界面组件java.swing.JPanel 一个存放用户界面组件的不可见的容器。面板可以嵌套。可以将面板放在包含面板的容器中。JPanel 也可用作画图的画布java.swing.JApplet Applet 的一个子类。必须扩展 JApplet 才能创建基于 Swing 的 Java appetjava.swing.JDialog 一个弹出式窗口或消息框，一般用作接收来自用户的附加信息或通知事件发生的临时窗口 GUI 辅助类辅助类都不是 Component 的子类，它们用来描述 GUI 组件的属性，例如：图形的内容、颜色、字体以及大小尺寸等 1234567 辅助类 说 明java.awt.Graphics 一个抽象类，提供绘制字符串、线和简单几何图形的方法java.awt.Color 处理 GUI 组件的颜色java.awt.Font 指定 GUI 组件上文本和图形的字体java.awt.FontMetrics 一个获取字体属性的抽象类java.awt.Dimension 将组件的宽度和高度（以整数为精度）封装在单个对象中java.awt.LayoutManager 指定组件在容器中如何放置 框架创建一个用户界面需要创建一个框架或一个 applet 来存放用户界面组件 布局管理器可以动态地改变布局管理器的属性FlowLayout（流式布局）具有属性 alignment、hgap 和 vgap，可以使用 setAlignment、setHgap 和 setVgap 方法来表明对齐方式、水平间隔和垂直间隔GridLayout（网格布局）具有属性 rows、columns、hgap 和 vgap，可以使用 setRows、setColums、setHgap 和 setVgap 方法来指定行数、列数以及水平间隔和垂直间隔BorderLayout（边界布局）具有属性 hgap 和 vgap，可以使用 setHgap 和 setVgap 方法来指定水平间隔和垂直间隔框架默认的布局是 BorderLayout，所以在框架中想要使用 BorderLayout，可以不进行指定，直接使用即可，JPanel 默认的布局是FlowLayout 即流式布局 Swing GUI 组件的公共特性Component 类是所有 GUI 组件和容器的根，所有 Swing GUI 组件（除了 JFrame、JApplet 和 JDialog）都是 JComponent 的子类 Swing GUI 组件常用的操作方法所有 Swing GUI 组件都继承 Component、Container 和 JComponent 的公共方法","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://wiyeelu.github.io/tags/Java/"},{"name":"GUI","slug":"GUI","permalink":"https://wiyeelu.github.io/tags/GUI/"},{"name":"API","slug":"API","permalink":"https://wiyeelu.github.io/tags/API/"}]},{"title":"Java 二进制I/O","slug":"Java-二进制I-O","date":"2019-03-29T07:09:54.000Z","updated":"2019-06-21T00:58:04.000Z","comments":true,"path":"2019/03/29/Java-二进制I-O/","link":"","permalink":"https://wiyeelu.github.io/2019/03/29/Java-二进制I-O/","excerpt":"Java 文本与二进制 I/O 总结(Java 流 Stream、文件 File 和 IO)","text":"Java 文本与二进制 I/O 总结(Java 流 Stream、文件 File 和 IO) 文本 I/O 与二进制 I/O二进制 I/O 不涉及编码和解码，因此更高效文本 I/O 建立在二进制 I/O 的基础之上，它提供一层抽象，用于字符层次自动进行的编码和解码Java 的类文件存储为二进制文件。因为二进制文件与主机编码方案无关，可移植，在任何机器上的 Java 程序可以读取 Java 程序创建的二进制文件。 流流 (stream) 的概念源于 UNIX 中管道 (pipe) 的概念。在 UNIX 中，管道是一条不间断的字节流，用来实现程序或进程间的通信，或读写外围设备、外部文件等形象的比喻：水流 文件 ——– 程序，文件和程序之间连接一个管道，水流就在之间形成了，自然就有方向，可以流进，也可以流出，即 流 就是一个管道里面有流水，这个管道连接了文件和程序 数据流分类流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种： 字节流：数据流中最小的数据单元是字节 字符流：数据流中最小的数据单元是字符， Java 中的字符是 Unicode 编码，一个字符占用两个字节123 字节流 字符流输入流 InputStream Reader输出流 OutputStream Writer Java 的字符流，采用的是 Unicode 标准，16 位，两个字节reader 是所有读取字符串输入流的祖先，而 writer 是所有输出字符串输出流的根类。 I/O 概览Java.io 包中最重要的就是 5 个类和 1 个接口： 类：File OutputStream InputStream Writer Reader 接口：Serializable I/O 层次分为 3 层1234561. File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等2. InputStream（字节流，二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征3. OutputStream（字节流，二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征4. Reader（字符流，文本格式操作）：抽象类，基于字符的输入操作5. Writer（字符流，文本格式操作）：抽象类，基于字符的输出操作6. RandomAccessFile（随机文件操作）：它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作 I/O 流java.io 包里有 4 个基本类：InputStream、OutputStream 及 Reader、Writer 类，它们分别处理字节流和字符流，其他流都是由这 4 个派生出来的： InputStream 类和 OutputStream 类InputStream 为字节输入流，它本身为一个抽象类，必须依靠其子类实现各种功能，此抽象类是表示字节输入流的所有类的超类。继承自 InputStream 的流都是向程序中输入数据的，且数据单位为字节（8bit）OutputStream 和 InputStream 是相对应的 FileInputStream 和 FileOutputStream一个流被定义为一个数据序列，输入流用于从源读取数据，输出流用于向目标写数据 FileInputStreamFileInputStream 用于从文件读取数据，它的对象可以用关键字 new 来创建有多种构造方法可用来创建对象： 可以使用字符串类型的文件名来创建一个输入流对象来读取文件 1InputStream f = new FileInputStream(\"C:/kt\"); 也可以使用一个文件对象来创建一个输入流对象来读取文件 12File f = new File(\"C:/kt\");InputStream out = new FileInputStream(f); FileOutputStream该类用来创建一个文件并向文件中写数据如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件有两个构造方法可以用来创建 FileOutputStream 对象 使用字符串类型的文件名来创建一个输出流对象 1OutputStream f = new FileOutputStream(\"C:/kt\"); 也可以使用一个文件对象来创建一个输出流来写文件 12File f = new File(\"C:/kt\");OutputStream f = new FileOutputStream(f);","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://wiyeelu.github.io/tags/Java/"},{"name":"I/O","slug":"I-O","permalink":"https://wiyeelu.github.io/tags/I-O/"},{"name":"二进制","slug":"二进制","permalink":"https://wiyeelu.github.io/tags/二进制/"},{"name":"文件","slug":"文件","permalink":"https://wiyeelu.github.io/tags/文件/"}]},{"title":"Java String类","slug":"Java-String类","date":"2019-03-29T02:51:20.000Z","updated":"2019-06-21T00:58:04.000Z","comments":true,"path":"2019/03/29/Java-String类/","link":"","permalink":"https://wiyeelu.github.io/2019/03/29/Java-String类/","excerpt":"Java 中字符串的支持是通过在 JDK 中提供一个名为 String 的类，对应字符串这个变量类型","text":"Java 中字符串的支持是通过在 JDK 中提供一个名为 String 的类，对应字符串这个变量类型 String 类的特点 String 类的底层使用 char 的数组保存数据 String 类是一个 final 类，不允许被继承 String 类是一个 immutable 类，该类的对象生成后，内容不会发生变化。该类中的所有返回 String 类型对象的成员方法都是返回一个新的 String 对象 方法区中有一块区域名为“常量区”, 用于存储编译时和运行时的字符串常量 String 类方法String 类作为对应字符串的类，该类中含有大量的方法用来完成字符串相关的构造、裁剪、拼接与替换等功能，大部分为方法重载 创建对象的两种方式Java 中的字符串对象比较特殊，比普通 Java 类有多一种创建对象的方法，即“字符序列法”12String strA = \"WiHieree\";String strB = new String(\"WiHieree\"); 以上两种方式创建的对象区别：12345678910111213141516171819public class StringTest &#123; public static void main(String[] args) &#123; String strA = \"Wihieree\"; String strB = \"Wihieree\"; System.out.println(strA == strB); System.out.println(strA.equals(strB)); String strC = new String(\"Wiyee\"); String strD = new String(\"Wiyee\"); System.out.println(strC == strD); System.out.println(strC.equals(strD)); &#125;&#125;//输出结果truetruefalsetrue 机制在于JVM内存模型的方法区中有一个 String 常量池（方法去内存），对于使用字符序列方式创建对象，JVM首先会查看字符串常量池中是否已经存在该对象，如果存在，则直接已存在对象而不会新建对象；对于使用 new 运算符方式创建对象，JVM会直接在堆中分配一个新的String对象，如下图所示： 字符串的比较（equals 与 ==） 对于 ==，如果作用与基本数据类型（byte、short、char、int、long、float、double、boolean）的变量,则比较的是其存储的“值”是否相等；如果作用与引用类型的变量，则比较其所指向的对象的地址是否相同（即是否同一个对象）。在 Java 中，String 是引用类型 String的 equals 方法继承自 Java 中的超级父类 Object，Object 的 equals 方法用来比较两个对象的引用是否相等（即是否同一个对象）。但是，String 的 equals 方法不仅是简单地继承，而是进行了重写(Override)，用来比较两个 String 对象所存储的字符序列值是否相等 intren 方法123456789101112public class StringTest &#123; public static void main(String[] args) &#123; String strA = \"WiHieree\"; String strB = new String(\"WiHieree\"); System.out.println(strA.intern().equals(strB.intern())); System.out.println(strA.intern() == strB.intern()); &#125;&#125;//输出结果truetrue 无论是字符串常量区中的 String 对象，还是堆内存中的 String 对象，它们的 intern 方法都是去 JVM 中的字符串常量区获取相等字符序列的 String 对象返回 值传递/引用传递Java 中只有值传递机制，而没有引用传递机制，所以 String 参数是值传递方式12345678910111213141516public class StringTest &#123; public static void main(String[] args) &#123; String arg = new String(\"WiHieree\"); change(arg); System.out.println(\"main arg ---&gt; \" + arg); &#125; private static void change(String arg) &#123; arg = \"Wiyee\"; System.out.println(\"chang arg ---&gt; \" + arg); &#125;&#125;//输出结果chang arg ---&gt; Wiyeemain arg ---&gt; WiHieree 字符串与数组之间的转换字符串不是数组，但是字符串可以转换成数组，反之亦然123字符 ----&gt; 数组 toCharArray char[] chars = \"WiHieree\".toCharArray();数组 ----&gt; 字符 String str = new String(new char[]&#123;'W','i','y','e','e'&#125;); String str = String.valueOf(new char[]&#123;'W','i','y','e','e'&#125;); String、StringBuffer 和 StringBuilder 的区别对象的可变与不可变StringBuffer/StringBuilder 类是可以替代 String 类的另一种处理字符串的解决方案，比 String 类更灵活可以给一个 StringBuilder或StringBuffer 中添加、插入或追加新的内容，但是 String 对象一旦创建，它的值就确定了 效率(使用 StringBuffer 连接字符串)除了 StringBuffer 中修改缓冲区的方法是同步的之外，StringBuilder 类与 StringBuffer 类是很相似的如果是多任务并发访问，就使用 StringBuffer ；而如果是单任务访问，使用 StringBuilder 会更有效123+StringBuilder() 构建一个容量为 16 的空的字符串生成器+StringBuilder(capacity: int) 构建一个指定容量的字符串生成器+StringBuilder(s: String) 构建一个带指定字符串的字符串生成器 eg. +append(data: char[]): StringBuilder 将字符串和字符追加到字符串生成器1234567891011121314public class StringTest &#123; public static void main(String[] args) &#123; StringBuilder a = new StringBuilder(); a.append(\"Welcome\"); a.append(\" \"); a.append(\"to\"); a.append(\" \"); a.append(\"WiyeeLu's blog\"); System.out.println(a); &#125;&#125;//输出结果Welcome to WiyeeLu's blog","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://wiyeelu.github.io/tags/Java/"},{"name":"String","slug":"String","permalink":"https://wiyeelu.github.io/tags/String/"}]},{"title":"Java异常","slug":"Java异常","date":"2019-03-27T03:23:54.000Z","updated":"2019-06-21T00:58:06.000Z","comments":true,"path":"2019/03/27/Java异常/","link":"","permalink":"https://wiyeelu.github.io/2019/03/27/Java异常/","excerpt":"异常的处理机制可以确保我们程序的健壮性，提高系统可用率","text":"异常的处理机制可以确保我们程序的健壮性，提高系统可用率 基本概念定义异常情形是指阻止当前方法或者作用域继续执行的问题Java 中采用“类”去模拟异常，类可以创建对象12345NullPointerException e = 0x1234;e 是引用类型， e 中保存的内存地址指向堆中的“对象”这个对象一定是 NullPointerException 类型这个对象就表示真实存在的异常事件NullPointerException 则表示一类异常 出现异常的情况：只有在当前的环境下程序无法正常运行，这时它就会从当前环境中跳出，并抛出异常 用户输入了非法数据 要打开的文件不存在 网络通信时连接中断，或者 JVM 内存溢出 异常处理机制的作用程序发生异常事件之后，为我们输出详细的信息，程序员通过这个信息，可以对程序进行处理，使程序更加健壮 eg. JVM 自动创建 ArithMeticException 类型的对象包含了对象的详细信息1234567891011public class ExceptionTest01 &#123; public static void main(String[] args) &#123; int a = 10; int b = 0; int c = a/b; //JVM 自动创建了对象 //ArithMeticException e = 0x2356; &#125;&#125; 异常的用途1234567891011121314public class Calculator &#123; public static void main(String[] args) &#123; double i = devide(10, 0); System.out.println(i); &#125; public static int devide(int num1, int num2) &#123; //判断除数是否为0 if(num2 == 0) &#123; throw new IllegalArgumentException(\"除数不能为零\"); &#125; return num1/num2; &#125;&#125; 以上程序编译通过了，但是运行时出现了异常，表示发生某个异常事件JVM 向控制台输出了如下信息：12Exception in thread \"main\" java.lang.ArithmeticException: / by zero at com.day032801.ExceptionTest01.main(ExceptionTest01.java:10) 本质：程序执行过程中发生了算数异常事件，JVM 为我们创建了一个 ArithMeticException 类型的对象并且这个对象中包含了详细的异常信息，并且 JVM 将这个对象中的信息输出到控制台 异常的体系结构通过以上示例，可以看到 Java 给我们提供了这样的体系结构：当出现问题的时候，它会告诉我们，并且把错误的详细信息也告诉我们了，这就是异常的体系结构，这样我们的程序就会更健壮，我们可以把这个信息再进行处理一下，告诉用户。从上面大家还可以看到，Java 异常都是类，在异常对象中会携带一些信息给我们，我们可以通过这个异常对象把信息取出来 异常类的层次结构 常见的异常类型 常见异常类型的处理方案11. java.lang.NullPointerException(空指针异常) 空指针异常发生在对象为空，但是引用了这个对象的方法12String s = null;//此时 s 为空int length = s.length();//发生空指针异常 12. java.lang.ClassNotFoundException(指定的类型不存在) 检查类的名称和路径是否正确，比如调用 Class.forName() ,类的名称不正确 13.java.lang.NumberFormatException(字符串转换为数字异常) 当试图将一个 String 转换为指定的数字类型，而该字符串却不满足数字类型要求的格式时，抛出该异常如现在讲字符型的数据 123456 转换为数值型数据时，是允许的但是如果字符型数据中包含了非数字型的字符，如 123#56 ，此时转换为数值型时就会出现异常。系统就会捕捉到这个异常 14.java.lang.IndexOutOfBoundsException(数组下标越界异常) 调用数组超过数组的长度，最好先查看一下数组的length，以免出现这个异常 15.java.lang.IllegalArgumentException(方法的参数错误) 比如 g.setColor(int red,int green,int blue) 这个方法中的三个值，如果有超过 255 的也会出现这个异常，因此一旦发现这个异常，我们要做的，就是赶紧去检查一下方法调用中的参数传递是不是出现了错误 16.java.lang.IllegalAccessException(没有访问权限) 当应用程序要调用一个类，但当前的方法即没有对该类的访问权限便会出现这个异常。对程序中用了 Package 的情况下要注意这个异常 17.java.lang.ArithmeticException(数学运算异常) 当算术运算中出现了除以零这样的运算就会出这样的异常 18.java.lang.ClassCastException(数据类型转换异常) 当试图将对某个对象强制执行向下转型，但该对象又不可转换为其子类的实例时将引发该异常 19.java.lang.FileNotFoundException(文件未找到异常) 当程序试图打开一个不存在的文件进行读写时将会引发该异常。该异常由 FileInputStream,FileOutputStream,RandomAccessFile 的构造器声明抛出即使被操作的文件存在，但是由于某些原因不可访问，比如打开一个只读文件进行写入，这些构造方法仍然会引发异常 110.java.lang.NoSuchMethodException(方法不存在异常) 当程序试图访问(修改或读取)某个方法，但是该方法不存在就会引发异常 111.java.lang.InstantiationException(实例化异常) 当试图通过 Class 的 newInstance() 方法创建某个类的实例,但程序无法通过该构造器来创建该对象时引发 Class 对象表示一个抽象类，接口，数组类，基本类型 该 Class 表示的类没有对应的构造器 112.java.lang.OutOfMemoryException(内存不足错误) 当可用内存不足以让 Java 虚拟机分配给一个对象时抛出该错误 113.java.lang.NoClassDefFoundException(未找到类定义错误) 当 Java 虚拟机或者类装载器试图实例化某个类，而找不到该类的定义时抛出该错误123456714 违背安全原则异常：SecturityException15 操作数据库异常：SQLException16 输入输出异常：IOException17 通信异常：SocketException 异常处理机制的主要组成12345try：监控有可能产生异常的语句块catch：以合理的方式捕获并处理异常finally：不管有无异常，一定会执行的语句块（一般用来释放资源等）throw：手动引发异常throws：指定由方法引发的异常 throw\\throws123public static void main(String[] args) throws Exception &#123;&#125; try…catch…finally1234567try&#123; //所监控的有可能产生异常的语句块&#125;catch(Exception e)&#123;//捕获异常，e 就是所捕获的异常对象 //异常处理：打印异常信息、日志记录等&#125;finally&#123; //不管有无异常，一定会执行的语句块（一般用来释放资源）&#125; catch 语块可以写多个，但是必须从上到下，从小到大（子类 –&gt; 父类） 深入 throws12345678910111213141516171819202122import java.io.*;public class ExceptionTest03 &#123; public static void main(String[] args) throws FileNotFoundException&#123; m1(); //不会输出 System.out.println(\"Wihieree\"); &#125; public static void m1() throws FileNotFoundException&#123; m2(); &#125; public static void m2() throws FileNotFoundException&#123; m3(); &#125; public static void m3() throws FileNotFoundException&#123; new FileInputStream(\"c:/ab.txt\"); //FileInputStream 构造方法声明位置上使用 throws（向上抛） &#125;&#125; 输出结果：123456789Exception in thread \"main\" java.io.FileNotFoundException: c:\\ab.txt (系统找不到指定的文件。) at java.base/java.io.FileInputStream.open0(Native Method) at java.base/java.io.FileInputStream.open(FileInputStream.java:219) at java.base/java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:157) at java.base/java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:112) at com.day032801.ExceptionTest03.m3(ExceptionTest03.java:20) at com.day032801.ExceptionTest03.m2(ExceptionTest03.java:16) at com.day032801.ExceptionTest03.m1(ExceptionTest03.java:12) at com.day032801.ExceptionTest03.main(ExceptionTest03.java:6) 使用 throws 处理异常不是真正处理异常而是推卸责任，谁调用的就会抛给谁因为 m1 方法出现异常采用的是上抛，给了 JVM , JVM 遇到这个异常就会退出 JVM ，下面的程序不会执行所以不会输出 Wihieree出现上面输出结果的原因是：123在程序运行过程中发生了 FileNotFoundException 类型的异常JVM 为我们创建了一个 FileNotFoundException 类型的对象该对象中携带上面的信息，JVM 负责将该对象的信息打印到控制台，并且 JVM 停掉了程序的运行 深入 try…catch…1234567891011121314151617181920import java.io.FileInputStream;import java.io.FileNotFoundException;public class ExceptionTest04 &#123; public static void main(String[] args) &#123; try&#123; //程序执行到此处发生了 FileNotFoundException 类型的异常 //JVM 会自动创建一个 FileNotFoundException 类型的对象 //将该对象的内存地址赋值给 catch 语句块中的 e 变量 FileInputStream fis = new FileInputStream(\"abc\"); //上面的代码出现了异常，try 语句块的代码不再继续执行，直接进入 catch 语句块中执行 System.out.println(\"WiHieree\"); &#125;catch(FileNotFoundException e)&#123; //e 内存地址指向堆中的那个对象是 “FileNotFoundException 类型的”事件 System.out.println(\"读取的文件不存在！\"); //FileNotFoundException 将 Object 中的 toString 方法重写 System.out.println(e);//java.io.FileNotFoundException: abc (系统找不到指定的文件。) &#125; &#125;&#125; getMessage() 和 printStackTrace() 方法printStackTrace() 输出信息更详细，更适合用于调试程序12345678910111213141516171819202122232425262728import java.io.FileInputStream;import java.io.FileNotFoundException;public class ExceptionTest04 &#123; public static void main(String[] args) &#123; try&#123; FileInputStream fis = new FileInputStream(\"abc\"); &#125;catch(FileNotFoundException e)&#123; //打印异常堆栈信息 //一般情况下都会使用该方式去调试程序 e.printStackTrace(); /* java.io.FileNotFoundException: abc (系统找不到指定的文件。) at java.base/java.io.FileInputStream.open0(Native Method) at java.base/java.io.FileInputStream.open(FileInputStream.java:219) at java.base/java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:157) at java.base/java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:112) at com.day032801.ExceptionTest04.main(ExceptionTest04.java:9) */ String msg = e.getMessage(); System.out.println(msg); //abc (系统找不到指定的文件。)上面方法的简略 &#125; //这段代码会执行 System.out.println(\"WiHieree\");//WiHieree &#125;&#125; finally 关键字finally 语句块可以直接和 try 语句块联用 try…finally…try…catch…finally 也可以在 finally 语句块中的代码是一定会执行的，但只要在 finally 之前退出了 JVM，finally 语句就不会执行eg. System.exit(0);1234567891011121314151617181920//深入 finally 语句块public class ExceptionTest05 &#123; public static void main(String[] args) &#123; int i = m1(); System.out.println(\"main 的 i --&gt; \" + i);//10 &#125; public static int m1()&#123; int i = 10; try&#123; return i; //10 &#125;finally &#123; i++; System.out.println(\"finally 的 i --&gt; \" + i);//11 &#125; &#125;&#125;//输出结果finally 的 i --&gt; 11main 的 i --&gt; 10 注意 mian 方法返回的 i 是 10，接受的是 try 里 return 的 i try…catch…finallyfinally 语句块是一定会执行的，所以通常在程序中为了保证某资源一定会释放，所以一般在 finally 语块中释放资源1234567891011121314151617181920212223242526import java.io.*;public class ExceptionTest06 &#123; public static void main(String[] args) &#123; //必须在外面声明 FileInputStream fis = null; try&#123; fis = new FileInputStream(\"E:/theme-66.epf\"); &#125;catch(FileNotFoundException e)&#123; e.printStackTrace(); &#125;finally &#123; //避免空指针异常，保证资源一定会释放 if (fis!=null)&#123; try&#123; fis.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;//输出结果 输出结果为空，因为没有异常，在 finally 已经释放资源 自定义异常异常的完整应用，其中包含手动抛出异常eg. 需求自定义注册“无效名字异常”1234567891011//自定义一个异常public class IllegalNameException extends Exception&#123;//编译时异常//public class IllegalNameException extends Exception&#123;//运行时异常 //定义异常一般提供两个构造方法 public IllegalNameException()&#123;&#125; public IllegalNameException(String msg)&#123; super(msg); &#125;&#125; 1234567891011121314151617181920//顾客相关的业务public class CustomerService &#123; //对外提供一个注册的方法 public void register(String name) throws IllegalNameException&#123; //完成注册 if (name.length()&lt;6)&#123; //异常 //创建异常对象 //IllegalNameException e = new IllegalNameException(\"用户名长度不能少于 6 位\"); //手动抛出异常 //throw e; throw new IllegalNameException(\"用户名长度不能少于 6 位\"); &#125; //如果代码能执行到此处，证明用户名是合法的 System.out.println(\"注册成功！\"); &#125;&#125; 1234567891011121314151617181920//模拟注册public class Test &#123; public static void main(String[] args) &#123; //加入用户提供的用户名如下 String username = \"wihie\"; //注册 CustomerService cs = new CustomerService(); try&#123; cs.register(username); &#125;catch(IllegalNameException e)&#123; System.out.println(e.getMessage()); &#125; &#125;&#125;//输出结果用户名长度不能少于 6 位 方法的重写与异常重写的方法不能比被重写的方法抛出更宽泛的异常123456789class A&#123; public void m1()&#123;&#125;&#125;class B extends A&#123; //子类永远无法抛出比父类更多的异常 public void m1() throws Exception&#123;&#125;&#125; 以上编译不通过1234567891011import java.io.FileNotFoundException;import java.io.IOException;class A&#123; public void m1() throws IOException &#123;&#125;&#125;class B extends A&#123; public void m1() throws FileNotFoundException&#123;&#125;&#125; 以上程序编译通过","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://wiyeelu.github.io/tags/Java/"},{"name":"异常处理","slug":"异常处理","permalink":"https://wiyeelu.github.io/tags/异常处理/"}]},{"title":"Java数组","slug":"Java数组","date":"2019-03-26T03:07:14.000Z","updated":"2019-06-21T00:58:06.000Z","comments":true,"path":"2019/03/26/Java数组/","link":"","permalink":"https://wiyeelu.github.io/2019/03/26/Java数组/","excerpt":"Java 提供了一个数据结构：数组，用于存储相同类型的元素的一个固定大小的连续集合。数组是用于存储数据的集合，但往往将数组认为是相同类型的变量的集合数组是一种效率最高的存储和随机访问对象引用序列的方式，在性能要求较高的场景中优先考虑数组","text":"Java 提供了一个数据结构：数组，用于存储相同类型的元素的一个固定大小的连续集合。数组是用于存储数据的集合，但往往将数组认为是相同类型的变量的集合数组是一种效率最高的存储和随机访问对象引用序列的方式，在性能要求较高的场景中优先考虑数组 一维数组声明数组变量首先必须声明数组变量，才能在程序中使用数组1234dateType[] arrayRefVar;eg.double[] myList; 创建、处理数组数量变量的声明和创建数组12345678dataType[] arrayRefVar = new dataType[arraySize];ordataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;;//求数组的大小,数组是定长的，一旦初始化声明后是不可改变长度的arrayRefVar.length eg.1234567891011121314151617181920212223242526public class Number &#123; public static void main(String[] args) &#123; double[] myList = &#123;7.2, 8.3, 2.0, 3.0&#125;; // 打印所有数组元素 for (int i = 0; i &lt; myList.length; i++) &#123; System.out.println(myList[i]); &#125; // 计算所有元素的总和 double total = 0; for (int i = 0; i &lt; myList.length; i++) &#123; total += myList[i]; &#125; System.out.println(total); // 查找最大元素 double max = myList[0]; for (int i = 1; i &lt; myList.length; i++) &#123; if (myList[i] &gt; max) max = myList[i]; &#125; System.out.println(max); &#125;&#125; 变长数组虽然数组是定长的，一旦初始化声明后是不可改变长度，但是我们可以利用 List 集合 add 方法里面的扩容思路来模拟实现思路：创建一个长度与原数组不同的新数组，让原数组变量指向新数组，实现长度可变ArrayList：动态数组，Array 的复杂版本 创建新数组，让原数组变量指向新数组 123456789101112131415161718package com.day032602;import java.util.Arrays;public class Number &#123; public static void main(String[] args) &#123; int[] src1 = new int[0]; int[] src2 = new int[3]; src1 = src2; src1[0] = 1; src1[1] = 2; src1[2] = 3; System.out.println(Arrays.toString(src1));//把数组转化成字符串输出 &#125;&#125;//输出结果[1,2,3] 使用 ArrayList 代替数组，通过泛型 ArrayList 可以储存不同类型的对象 123456789101112131415161718package com.day032602;import java.util.Arrays;import java.util.ArrayList;public class Number &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; a = new ArrayList&lt;&gt;(); a.add(1); a.add(2); a.add(3); //输出数组元素数量 System.out.println(a.size()); &#125;&#125;//输出结果3 for-each 循环for-each 循环或者加强型循环，它能在不使用下标的情况下遍历数组12345//语法格式for(type element: array)&#123; System.out.println(element);&#125; eg.123456789101112131415161718public class Number &#123; public static void main(String[] args) &#123; double[] myList = &#123;7.2, 8.3, 2.0, 3.0&#125;; //打印所有数组元素 for (double element: myList)&#123; System.out.println(element); &#125; &#125;&#125;//输出结果7.28.32.03.0 数组的查找查找是在数组中寻找特定元素的过程两种常用的方法：线性查找（linear searching）和二分查找（binary searching） 线性查找法线性查找法将要查找的关键字 key 与数组中的元素逐个进行比较。如果匹配成功，线性查找法则返回与关键字匹配的元素在数组中的下标；如果没有匹配成功，则返回 -1eg.123456789101112131415161718192021222324252627public class Number &#123; private static int LinearSearch(int[] list,int key) &#123; for(int i = 0;i &lt; list.length;i++)&#123; if(key == list[i])&#123; return i; &#125; &#125; return -1; &#125; public static void main(String[] args) &#123; int[] list = &#123;1, 3, 5, 7, -3&#125;; int number1 = LinearSearch(list, 1); int number2 = LinearSearch(list, 7); int number3 = LinearSearch(list, -5); System.out.println(number1); System.out.println(number2); System.out.println(number3); &#125;&#125;//输出结果03-1 线性查找法把关键字和数组中的每一个元素进行比较，效率不高 二分查找法使用二分查找法的前提条件是数组中的元素必须已经排好序，假设数组已经按升序排，二分查找法首先将关键字与数组的中间元素进行比较，考虑下面三种情况： 如果关键字小于中间元素，只需要在数组的前一半元素中继续查找关键字 如果关键字等于中间元素，则匹配成功，查找结束 如果关键字大于中间元素，只需要在数组的后一半元素中继续查找关键字 eg.123456789101112131415161718192021222324252627282930313233343536373839public class Number &#123; private static int binarySearch(int[] list,int key) &#123; int low = 0; int high = list.length - 1; //直到low &gt; high时还没找到关键字就结束查找，返回 -1 while(low &lt;= high)&#123; int mid = (low + high)/2; if(key &lt; list[mid])&#123; high = mid - 1; &#125; else if(key &gt; list[mid])&#123; low = mid + 1; &#125; else if(key == list[mid])&#123; return mid; &#125; &#125; return -1; &#125; public static void main(String[] args) &#123; int[] list = &#123;1,3,5,7,9,10,11,13,15,17&#125;; int number1 = binarySearch(list,7); int number2 = binarySearch(list,11); int number3 = binarySearch(list,23); System.out.println(number1); System.out.println(number2); System.out.println(number3); &#125;&#125;//输出结果36-1 数组排序eg.1234567891011121314151617181920212223242526272829import java.util.Arrays;import java.util.Collections;public class Number &#123; public static void main(String[] args) &#123; //升序排序 //定义一个整型数组 int[] scores = &#123; 78, 93, 84, 64 &#125;; //使用 Arrays 类的 sort() 方法对数组进行升序排序 Arrays.sort(scores); System.out.println(\"升序排序后数组中元素的值：\"); System.out.println(Arrays.toString(scores)); //倒序排序 //这里必须把 int 类型写成 Integer 类型才能通过 Integer [] scores1 = &#123; 78, 93, 84, 64 &#125;; //使用 Arrays 类的 sort() 方法对数组进行倒序排序 Arrays.sort(scores1,Collections.reverseOrder()); System.out.println(\"倒序排序后数组中元素的值：\"); System.out.println(Arrays.toString(scores1)); &#125;&#125;//输出结果升序排序后数组中元素的值：[64, 78, 84, 93]倒序排序后数组中元素的值：[93, 84, 78, 64] Arrays 类java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的导入1import java.util.Arrays; 给数组赋值：通过 fill 方法 对数组排序：通过 sort 方法，按升序 比较数组：通过 equals 方法比较数组中元素值是否相等 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作1234//用二分查找算法在给定数组中搜索给定值的对象public static int binarySearch(Object[] a, Object key)//导入包之后引用：Arrays.binarySearch(Object[] a, Object key); 123456//如果两个指定的 long 型数组彼此相等，则返回 true//如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的//则认为这两个数组是相等的public static boolean equals(long[] a, long[] a2)//导入包之后引用：Arrays.equals(long[] a, long[] a2); 12345678910111213141516171819202122232425262728//填充数组public static void fill(int[] a, int val)//eg.import java.util.Arrays;public class Number &#123; public static void main(String[] args) &#123; int [] a = &#123; 10, 20 , 36, 50&#125;; //填充 a[1] 到 a[3-1] 为 8 Arrays.fill(a,1,3,8); System.out.println(Arrays.toString(a)); //输出 [10, 8, 8, 50] &#125;&#125;public class Number &#123; public static void main(String[] args) &#123; int [] a = &#123; 10, 20 , 36, 50&#125;; //全部填充为8 Arrays.fill(a,8); System.out.println(Arrays.toString(a)); //输出 [8, 8, 8, 8] &#125;&#125; 多维数组新建一个二维数组12345678910111213141516public class Number &#123; public static void main(String[] args) &#123; int [][] a = &#123;&#123;2, 6, 8&#125;,&#123;7, 3, 9&#125;&#125;; //访问二维数组的长度 System.out.println(a[0].length); //打印数组，for 循环 for (int row = 0; row &lt; a.length ; row++)&#123; for (int column = 0; column &lt; a[row].length ; column++)&#123; System.out.println(a[row][column] + \" \"); &#125; System.out.println(); &#125; &#125;&#125; 数组线性表 ArrayList 类Java 提供 ArrayList 类来存储不限定个数的对象优点： 容量不固定（有一个较大的最大阈值） 有序的（与输入顺序一致） 元素可以为 null 效率高 占用空间更小 ArrayList 中的一些方法：1234567891011ArrayList() 创建一个空的线性表add(o: Object): void 在这个线性表的末尾追加一个新元素 0add(index: int, o:Object): void 在这个线性表的特定下标处增加一个新元素 0clear(): void 从这个线性表中删除所有的元素contains(o:Object): boolean 如果这个线性表包含元素 0 则返回 trueget(index: int): Object 返回这个线性表在特定下标处的元素indexOf(o:Object): int 返回这个线性表中第一个匹配元素的下标isEmpty(): boolean 如果这个线性表不包含元素则返回 truelastIndexOf(o:Object): int 返回这个线性表中最后一个匹配元素的下标remove(o:Object): boolean 删除指定下标处的元素set(index: int, o:Object): Object 设置在特定下标处的元素 eg.使用 ArrayList 存储对象1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.ArrayList;public class Array &#123; public static void main(String[] args) &#123; ArrayList cityList = new ArrayList(); cityList.add(\"Hongkong\"); cityList.add(\"London\"); cityList.add(\"Paris\"); System.out.println(\"数组大小： \" + cityList.size()); System.out.println(\"HongKong 在数组里吗？ \" + cityList.contains(\"Hongkong\")); System.out.println(\"HongKong 在数组的哪个位置： \" + cityList.indexOf(\"Hongkong\")); System.out.println(\"这个数组是空的吗？ \" + cityList.isEmpty()); //在数组第 2 的位置增加 Guangdong cityList.add(2,\"Guangdong\"); //移除 London cityList.remove(\"London\"); //移除 Paris cityList.remove(2); //以字符串形式输出数组 System.out.println(cityList.toString()); //for 循环遍历数组 for (int i = cityList.size() - 1; i&gt;=0;i--) &#123; System.out.println(cityList.get(i) + \" \"); &#125; &#125;&#125;//输出结果数组大小： 3HongKong 在数组里吗？ trueHongKong 在数组的哪个位置： 0这个数组是空的吗？ false[Hongkong, Guangdong]Guangdong Hongkong 数组和 ArrayList 之间的异同可以像使用数组一样使用 ArrayList 对象，但是两者还是有很多不同之处一旦创建了一个数组，它的大小就确定下来了。可以使用方括号访问数组元素（eg. a[index]）。当创建 ArrayList 后，它的大小为 0 。如果元素不在线性表中，就不能使用 get 和 set 方法。向线性表中添加，插入和删除元素是比较容易的，而向数组中添加、插入和删除元素是比较复杂的。为了实现这些操作，必须编写代码操纵这个数组 12345678910 操作 数组 ArrayList创建数组/ArrayList Object[] a = new Objext[10] ArrayList list = new ArrayList()引用元素 a [index] list.get(index)更新元素 a [index] = \"Hongkong\"; list.set(index,\"Hongkong\");返回大小 a length list.size()添加一个新元素 list.add(\"Hongkong\")插入一个新元素 list.add(index,\"Hongkong\")删除一个元素 list.remove(index);删除一个元素 list.remove(Object)删除所有元素 list.clear()","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://wiyeelu.github.io/tags/Java/"},{"name":"数组","slug":"数组","permalink":"https://wiyeelu.github.io/tags/数组/"},{"name":"array","slug":"array","permalink":"https://wiyeelu.github.io/tags/array/"}]},{"title":"理解Java面对对象的三大特性--封装、继承、多态","slug":"理解Java面对对象的三大特性-封装、继承、多态","date":"2019-03-25T06:24:21.000Z","updated":"2019-06-21T00:58:06.000Z","comments":true,"path":"2019/03/25/理解Java面对对象的三大特性-封装、继承、多态/","link":"","permalink":"https://wiyeelu.github.io/2019/03/25/理解Java面对对象的三大特性-封装、继承、多态/","excerpt":"Java 面对对象的三大特征是：封装、继承、多态继承是为多态的实现做准备","text":"Java 面对对象的三大特征是：封装、继承、多态继承是为多态的实现做准备 封装定义隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别 封装的目的增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，一特定的访问权限来使用类的成员 封装的好处良好的封装能够减少耦合类内部的结构可以自由修改可以对成员进行更精确的控制隐藏信息，实现细节 继承概念继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率 使用继承的场景当两个类具有相同的特征（属性）和行为（方法）时，可以将相同的部分抽取出来放到一个类中作为父类，其它两个类继承这个父类 使用继承的优点子类拥有父类非 private 的属性和方法，但是不能继承构造器，构造器只能被调用 super();（注意 super(); 必须是构造方法中的第一条语句）eg.123456789101112131415161718192021222324252627//A.javapublic class A &#123; A()&#123; System.out.println(\"star!!\"); &#125;&#125;//B.javapublic class B extends A&#123; B()&#123; super();//必须在第一行 System.out.println(\"aaa\"); &#125;&#125;//Test.javapublic class Test &#123; public static void main(String[] args) &#123; B b = new B(); &#125;&#125;//输出结果star!!aaa 子类可以拥有自己属性和方法，即子类可以对父类进行扩展子类可以用自己的方式实现父类的方法实现代码共享，避免重复外，还可以使得修改扩展继承而来的实现比较简单 多态概念定义多态，是面向对象的程序设计语言最核心的特征。多态，意味着一个对象有着多重特征，可以在特定的情况下，表现不同的状态，从而对应着不同的属性和方法即同一个事件发生在不同的对象上会产生不同的结果（同样是 Animal 的 voice()，但是 Cat/Dog 不同对象产生的 voice() 结果是不一样的） 实现技术动态绑定，是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法 作用消除类型之间的耦合关系程序的可扩展性及可维护性增强 多态的例子举一个通俗易懂的：比如有动物（Animal）之类别（class），由动物继承出类别鸟（Bird）、类别兔子（Ribbit）和猫（Cat），它们对同一源自类别动物（父类别）之一信息有不同的响应，如类别动物有“移动（）”这个动作，而类别鸟会“飞（）”，类别兔子会“跳（）”，类别猫则会“跑（）”，这就是多态，即相同的消息给予不同的对象会引发不同的动作 多态的实现Java 中有两种形式可以实现多态：基于继承实现多态和基于接口实现多态 多态存在的三个必要条件1 要有继承关系 （继承）2 子类要重写父类的方法 （重写）3 父类引用指向子类对象 （向上转型）只要满足了上述三个条件，我们才能够在同一继承结构中使用统一的逻辑实现代码处理不同的对象，达到执行不同的行为，即多态 基于继承实现多态基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为 eg.123456789101112131415161718192021222324252627282930313233343536//定义超类 Carpublic class Car &#123; void start()&#123; System.out.println(\"汽车发动机启动\"); &#125;&#125;//定义子类 XiaoHuangYapublic class XiaoHuangYa extends Car&#123; void start()&#123; System.out.println(\"小黄鸭的 Audi-RS5 发动机启动\"); &#125;&#125;//定义子类 TuoHaipublic class TuoHai extends Car&#123; void start()&#123; System.out.println(\"拓海的 丰田AE86 发动机启动\"); &#125;&#125;//测试类 Testpublic class Test &#123; public static void main(String[] args) &#123; Car c1 = new XiaoHuangYa(); Car c2 = new TuoHai(); c1.start(); //小黄鸭的 Audi-RS5 发动机启动 c2.start(); //拓海的 丰田AE86 发动机启动 &#125;&#125;//运行结果：小黄鸭的 Audi-RS5 发动机启动拓海的 丰田AE86 发动机启动 上述程序遵循的原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，在子类被覆盖的方法；当子类重写父类的方法被调用时，只有对象继承链中的最末端的方法才会被调用若超类是一个抽象类的时候，抽象类的子类必须覆盖实现超类中的所有的抽象方法，否则子类必须被 abstract 修饰符修饰，但是被 abstract 修饰之后不能被实例化 基于接口实现多态接口的灵活性就在于“规定一个类必须做什么，而不管你如何做”。我们可以定义一个接口类型的引用变量来引用实现接口的类的实例，当这个引用调用方法时，它会根据实际引用的类的实例来判断具体调用哪个方法，这和上述的超类对象引用访问子类对象的机制相似。继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性 eg.12345678910111213141516171819202122232425262728293031323334//定义一个接口public interface CustomerService &#123; //定义一个退出系统的方法 void logout();&#125;//定义一个类实现该接口public class CustomerServiceImpl implements CustomerService&#123; //对接口中的抽象方法进行实现 public void logout() &#123; System.out.println(\"成功退出系统！\"); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; //要执行 CustomerServiceImpl 中的 logout 方法 //以下程序面向接口去调用 CustomerService cs = new CustomerServiceImpl(); //多态 //调用 cs.logout(); &#125;&#125;输出结果：成功退出系统！ Java 在利用接口变量调用其实现类的对象的方法时，该方法必须已经在接口中被声明，而且在接口的实现类中该实现方法的类型和参数必须与接口中所定义的精确匹配 继承链中的优先级继承链中对象方法的调用存在一个优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)即先查 this 对象的父类，没有就重头再查参数的父类 eg. 优先级的体现 新建一个 A.java 123456789public class A &#123; public String show(D obj)&#123; return (\"A adn D\"); &#125; public String show(A obj)&#123; return (\"A and A\"); &#125;&#125; 新建一个 B.java 继承 A.java 123456789public class B extends A&#123; public String show(B obj)&#123; return (\"B and B\"); &#125; public String show(A obj)&#123; return(\"B and A\"); &#125;&#125; 新建一个 C.java 继承 B.java 123public class C extends B&#123;&#125; 新建一个 D.java 继承 B.java 123public class D extends B&#123;&#125; 新建一个 Tesy.java 1234567891011121314151617181920212223public class Tesy &#123; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println(\"1--&gt; \" + a1.show(b)); System.out.println(\"2--&gt; \" + a1.show(c)); System.out.println(\"3--&gt; \" + a1.show(d)); System.out.println(\"4--&gt; \" + a2.show(b)); System.out.println(\"5--&gt; \" + a2.show(c)); System.out.println(\"6--&gt; \" + a2.show(d)); System.out.println(\"7--&gt; \" + b.show(b)); System.out.println(\"8--&gt; \" + b.show(c)); System.out.println(\"9--&gt; \" + b.show(d)); &#125;&#125; 输出结果：1234567891--&gt; A and A2--&gt; A and A3--&gt; A adn D4--&gt; B and A5--&gt; B and A6--&gt; A adn D7--&gt; B and B8--&gt; B and B9--&gt; A adn D 该多态经典例子来自：Csdn-例子 看完例子，加入一些自己的理解，通过例子，对继承链中的优先级进行分析 学习完多态对于 1 - 7 都是比较好理解的，继承链中的优先级较好地体现在 8 9 先对 8 进行分析：b.show(c)，b 是 B 类型的引用变量，所以 this 就代表了 B，b.show(c)，它在 B 类中发现没有找到，于是到 B 的超类中找 (super)，由于 B 的超类是 A，所以到 A 找，super.show(0)，它在 A 类中发现没找到，现在到第 3 级 –&gt; this.show((super)0)，C 的超类有 B、A ，所以 (super)0 为 B、A ，this 依然是 B，现在在 B 类中找到了 show(B obj)，因此最终会调用 B 类的 show(B obj)方法，结果是 “B and B” 再对 9 进行分析：b.show(d), b 是 B 类型的引用变量，所以 this 就代表了 B，b.show(d)，它在 B 类中发现没有找到，于是到 B 的超类中找 (super)，由于 B 的超类是 A，所以到 A 找，super.show(0)，现在在 A 类中找到了 show(D obj)，因此最终会调用 A 类的 show(D obj)方法，结果是 “A and D” 通过修改 B.java ，删去 show(B obj) 方法，进一步说明继承链中的优先级 修改 8.java1234567public class B extends A&#123; public String show(A obj)&#123; return(\"B and A\"); &#125;&#125; 再运行 Tsey.java 会发现 8 的结果变成 “B and A”对 8 变化的结果进行分析：当第三步在 B 类中没有找到 this.show((super)0)，再到第 4 级 –&gt; super.show((super)O)，B 的超类为 A ，所以 super 为 A ，现在在 A 类中找到了 show(A obj)，由于 b 是 B 类型的引用，在 B 类中重写了 show(A obj)，因此最终会调用 B 类的 show(A obj) 方法，结果是 “B and A” 修改 8.java 再把重写的 show(A obj) 方法删去123public class B extends A&#123;&#125; 再运行 Tsey.java 会发现 8 的结果变成 “A and A”对 8 变化的结果进行分析：因为在第 4 级 A 类中找到 show(A obj) 方法，虽然 b 是 B 类型的引用，但是 B 类继承 A 类之后并没有重写 show(A obj) 方法，因此最终会调用 A 类的 show(A obj) 方法，结果是 “A and A”","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://wiyeelu.github.io/tags/Java/"},{"name":"封装","slug":"封装","permalink":"https://wiyeelu.github.io/tags/封装/"},{"name":"继承","slug":"继承","permalink":"https://wiyeelu.github.io/tags/继承/"},{"name":"多态","slug":"多态","permalink":"https://wiyeelu.github.io/tags/多态/"}]},{"title":"Java类和对象","slug":"Java 类和对象","date":"2019-03-22T01:57:21.000Z","updated":"2019-06-21T00:58:04.000Z","comments":true,"path":"2019/03/22/Java 类和对象/","link":"","permalink":"https://wiyeelu.github.io/2019/03/22/Java 类和对象/","excerpt":"个人学习之后对于 Java 类和对象的理解 类是一个模板，它描述一类对象的行为和状态，从类到对象即为实例化，从对象到类为抽象","text":"个人学习之后对于 Java 类和对象的理解 类是一个模板，它描述一类对象的行为和状态，从类到对象即为实例化，从对象到类为抽象 Java 类Java 类分为外部类和内部类类可以看成是创建 Java 对象的模板eg. 创建一个狗的类123456789101112131415161718192021public class Dog&#123; String breed; //品种 int age; //年龄 String color; //颜色 //以下为该 Dog 类的方法 //叫 void barking()&#123; System.out.println(\"小狗在叫\"); &#125; //饿 void hungry()&#123; System.out.println(\"小狗饿了\"); &#125; //睡觉 void sleeping()&#123; System.out.println(\"小狗在睡觉\"); &#125;&#125; Java 外部类外部类只有 public 和 default(缺省) 两种修饰如果一个类声明的时候使用了 public class 进行了声明，则类名称必须与文件名称完全一致如果一个类声明的时候使用了 class 进行了声明，则作为启动类的名称可以与文件名称不一致，但是执行的时候肯定执行的是生成后的名称在一个 *.java 文件中，只能有一个 public class 的声明（公共接口），但是允许有多个 class 声明；public 类不是必须的123456789//公开可访问，被 public 修饰的类可以被其他包访问public class Student&#123;&#125;//同一个包内可访问，该类不能被其他包访问class&#123;&#125; Java 内部类在外部类的内部再声明一个类则称为内部类，内部类有：静态内部类、成员内部类、局部内部类、匿名内部类内部类均可结合变量进行理解 静态内部类静态内部类可以等同看作静态变量，可以用 public,protected,private 修饰可以定义静态或者非静态的成员静态内部类的作用是：可以访问外部类中私有的数据看到带有 $ 符号的 .class 文件基本是内部类静态内部类可以直接访问外部类的静态数据，无法直接访问成员eg.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* * 关于静态内部类 * 1、静态内部类可以等同看作静态变量 * * 内部类重要的作用：可以访问外部类中私有的数据 * * 2、静态内部类可以直接访问外部类的静态数据，无法直接访问成员 */public class OuterClass &#123; //静态变量 static String s1 = \"A\"; //成员变量 private static String s2 = \"B\"; //静态方法 private static void m1() &#123; System.out.println(\"static's m1 method execute!\"); &#125; //成员方法 private void m2() &#123; System.out.println(\"m2 method execute!\"); &#125; //静态内部类 //可以用访问控制权限的修饰符修饰 //public,protected,private,缺省 static class InnerClass&#123; //静态方法 public static void m3() &#123; System.out.println(s1); m1(); //System.out.println(s2); //m2(); &#125; //成员方法 public void m4() &#123; System.out.println(s1); m1(); //System.out.println(s2); //m2(); &#125; &#125; //入口 public static void main(String[] args) &#123; //执行 m3 OuterClass.InnerClass.m3(); //执行 m4 InnerClass inner = new OuterClass.InnerClass(); inner.m4(); &#125;&#125; 成员内部类成员内部类可以等同看作成员变量区别于局部内部类的地方是定义在方法外成员内部类中不能有静态声明成员内部类可以访问外部类所有的数据eg.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* * 关于成员内部类 * * 1、成员内部类可以等同看作成员变量 * * 2、成员内部类中不能有静态声明 * * 3、成员内部类可以访问外部类所有的数据 */public class OuterClass02 &#123; // 静态变量 static String k1 = \"A\"; // 成员变量 private static String k2 = \"B\"; // 静态方法 private static void y1() &#123; System.out.println(\"static's y1 method execute!\"); &#125; // 成员方法 private void y2() &#123; System.out.println(\"y2 method execute!\"); &#125; // 成员内部类 // 可以用访问控制权限的修饰符修饰 // public,protected,private,缺省 class InnerClass &#123; // 静态方法 /* * public static void y3() &#123; * * &#125; */ // 成员方法 public void y4() &#123; System.out.println(k1); y1(); System.out.println(k2); y2(); &#125; &#125; // 入口 public static void main(String[] args) &#123; // 创建外部类对象 OuterClass02 oc = new OuterClass02(); InnerClass inner = oc.new InnerClass(); inner.y4(); &#125;&#125; 局部内部类局部内部类等同于局部变量区别于成员内部类的地方是定义在方法内局部内部类不能有静态声明重点：局部内部类在访问局部变量的时候，局部变量必须使用 final 修饰eg.12345678910111213141516171819202122232425262728293031323334353637/* * 局部内部类等同于局部变量 * * 重点：局部内部类在访问局部变量的时候，局部变量必须使用 final 修饰 */public class OuterClass03 &#123; //方法 public void f1() &#123; //局部变量 final int i = 10; //局部内部类 //局部内部类不能用访问控制权限修饰符修饰 class InnerClass&#123; //内部类不能有静态声明 //public static void m1() &#123;&#125; //成员方法 public void f2() &#123; System.out.println(i);//10 &#125; &#125; //调用 m2 InnerClass inner = new InnerClass(); inner.f2(); &#125; //入口 public static void main(String[] args) &#123; OuterClass03 oc = new OuterClass03(); oc.f1(); &#125;&#125; 匿名内部类匿名类不能使用任何关键字和访问控制符 eg.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * 匿名内部类：指的是类没有名字 */public class Test01 &#123; //静态方法 public static void t(CustomerService cs) &#123; cs.logout(); &#125; //入口 public static void main(String[] args) &#123; //调用 t 方法 //t(new CustomerServiceImpl()); //使用匿名内部类的方式执行 t 方法 //整个这个 \"new CustomerService()&#123;&#125;\" 就是个匿名内部类 t(new CustomerService() &#123; public void logout() &#123; System.out.println(\"系统已经安全退出！\"); &#125; &#125;); //匿名内部类的优点：少定义一个类 //缺点：无法重复使用！ &#125;&#125;//接口interface CustomerService&#123; //退出系统 void logout();&#125;//不使用匿名内部类的情况//编写一个类实现 CustomerService 接口/*class CustomerServiceImpl implements CustomerService&#123; public void logout() &#123; System.out.println(\"系统已经安全退出！\"); &#125;&#125;*/ 局部、静态、成员内部类的访问区别eg. 局部内部类的访问1234567891011121314//访问局部内部类必须先有外部类对象public class Outer&#123; public void f(final int k)&#123; //局部内部类 class Inner&#123;//定义在方法内部 …… &#125; &#125; public static void main(String[] args)&#123; //访问局部内部类必须先有外部类对象 Outer out = new Outer(); out.f(2); &#125;&#125; eg. 静态内部类的访问12345678910111213//外部类访问内部类的非静态成员：实例化内部类即可public class Outer&#123; //静态内部类 static class Inner&#123; static void inner_f1()&#123; &#125; &#125; public void outer_f2&#123; //访问 Inner inn = new Inner(); inn.inner_f1(); &#125;&#125; eg. 成员内部类的访问123456789101112131415161718192021public class Outer&#123; class Inner&#123; void inner_f1()&#123; …… &#125; &#125; //外部类的非静态方法访问成员内部类 public void outer_f1()&#123; Inner inn = new Inner(); inn.inner_f1(); &#125; //外部类的静态方法访问成员内部类 public static void outer_f2()&#123; //建立外部类对象 Outer out = new Outer(); //根据外部类对象建立内部类对象 Inner inn = out.new Inner(); //访问内部类的方法 inn.inner_f1(); &#125;&#125; 对象面向对象三大特征：封装、继承、多态11. 封装：问权限控制 public &gt; protected &gt; 缺省 &gt; private 内部类也是一种封装 public 公开，任何位置都可以访问protected 同包，子类缺省 同胞private 私有，只能在本类中访问1232. 继承：一般类只能单继承，内部类实现多继承，接口可以多继承3. 多态：编译时多态，体现在向上转型和向下转型，通过引用类型判断调用哪个方法（静态分派）。 运行时多态，体现在同名函数通过不同参数实现多种方法（动态分派）。 对象具有状态和行为，从类到对象即为实例化从类中创造对象： 声明：声明一个对象，包括对象名称和对象类型 实例化：使用关键字 new 来创建一个对象 初始化：使用 new 创建对象时，会调用构造方法初始化对象; eg. Dog gg = new Dog();eg. 下面创建一个名为 Puppy 的狗对象12345678910public class Puppy&#123; public Puppy(String name)&#123; //这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); &#125; public static void main(String[] args)&#123; // 下面的语句将创建一个Puppy对象 Puppy myPuppy = new Puppy( \"tommy\" ); &#125;&#125; 实例化对象后访问实例变量和方法123456//实例化对象ObjectReference = new Constructor();//访问类中的变量ObjectReference.variableName;//访问类中的方法ObjectReference.methodName(); eg. 定义一个计算机类和学生类，让其中一个学生去使用其中的一台某品牌的某型号笔记本电脑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * 需求： * 定义一个计算机类（电脑/笔记本）属性： * - 品牌 * - 型号 * - 颜色 * * 定义一个学生类属性： * - 学号 * - 姓名 * - 学生有一台笔记本电脑 * * 请编写程序来表示以上的类，分别将类创建为对象 * 对象数量不限，然后让其中的一个学生去使用其中的一台笔记本电脑 * * 编译并运行，并且将整个执行过程采用图形的方式描述出来 */public class OOTest06 &#123; public static void main(String[] args) &#123; Computer emt = new Computer(); emt.brand = \"SummerCommpany\"; emt.number = \"SUM-002\"; Stuu kmt = new Stuu(); kmt.no = 6623798; kmt.name = \"WiHieree\"; emt.s = kmt; kmt.c = emt; System.out.println(kmt.name + \" 使用的电脑是 \" + kmt.c.brand + \" 旗下的 \" + kmt.c.number); &#125;&#125;class Computer&#123; String brand; String number; String col; Stuu s;&#125;class Stuu&#123; int no; String name; Computer c;&#125; 封装所有属性私有化，使用 private 关键字进行修饰，private 表示私有的，修饰的所有数据,使得数据只能在本类访问封装主要是因为 Java 有访问权限的控制 public &gt; protected &gt; package &gt; default &gt; private12 封装可以保护类中的信息，只提供想要被外界访问的信息对外提供简单的操作入口12345678910111. 对外提供两个公开的方法，分别是 set 方法和 get 方法2. 想修改 age 属性，调用 set 方法 命名规范： public void setAge(int a)&#123; &#125;3. 想读取 age 属性，调用 get 方法 命名规范： public int getAge()&#123; return age; &#125; eg. 新建一个 User.java ，并进行封装保证输入年龄在合理范围内12345678910111213141516171819202122232425262728293031323334package com.wihieree01;public class User &#123; //属性私有化 private int age;/*set 方法没有返回值，因为 set 方法只负责修改数据public void setAge(int age) &#123;age = age; // Java 有就近原则，这里其实并没有给 age 属性赋值，这里的 age 都是局部变量 age&#125;*/ public void setAge(int a) &#123; //编写业务逻辑代码进行安全控制 //age = a; if(a &lt;0 || a &gt; 150) &#123; System.out.println(\"对不起，您提供的年龄不合法\"); return; &#125; //程序可以执行到这里，说明 a 年龄是合法的，则进行赋值运算 age = a; &#125; //getter public int getAge() &#123; return age; &#125;&#125; eg. 新建一个 UserTest.java 创建一个 User 对象12345678910111213141516171819202122232425package com.wihieree01;public class UserTest &#123; public static void main(String[] args) &#123; //创建 User 对象 User user = new User(); //编译报错，age 属性私有化，在外部程序中不能直接访问 //从此之后 age 属性非常安全，但是有点太安全了 //对于目前的程序来说，age 属性彻底在外部访问不到了 //System.out.println(user.age); //在 User.Java 添加 setter and getter 方法 //修改 //user.setAge(-100); //对不起，您提供的年龄不合法 user.setAge(23); // 23 //读取 System.out.println(user.getAge()); &#125;&#125; 构造方法构造方法的作用：创建对象和在创建对象的同时，初始化实例变量的内存空间eg. 创建一个银行客户对象，查看户主名称，账号和余额 创建一个 Account.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.wihieree02;//账户类public class Account &#123; //户主 private String name; //账号 private String actno; //余额 private double balance; //有参数构造方法 public Account(String name,String actno,double balance)&#123; this.name = name; this.actno = actno; this.balance = balance; &#125; //封装 get / set public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getActno() &#123; return actno; &#125; public void setActno(String actno) &#123; this.actno = actno; &#125; public double getBalance() &#123; return balance; &#125; public void setBalance(double balance) &#123; this.balance = balance; &#125;&#125; 创建一个 ConstructorTest.java 1234567891011121314151617package com.wihieree02;public class ConstructorTest02 &#123; public static void main(String[] args) &#123; //查看访问的是哪个属性按 Ctrl + 鼠标移动到查看的元素上单击 //创建对象 Account act1 = new Account(\"WiHieree\",\"SUM-0984\",1980000.0); System.out.println(\"户主：\" + act1.getName()); //户主：WiHieree System.out.println(\"账号：\" + act1.getActno()); //账号：SUM-0984 System.out.println(\"余额：\" + act1.getBalance()); //余额：1980000.0 &#125;&#125; 继承继承的基本作用是：代码复用，但是继承最重要的作用是：有了继承才有了以后方法的覆盖和多态机制Java 中的继承只能单继承，但是可以通过内部类继承其他类来实现多继承语法结构：1234567[修饰符列表] class 类名 extends 父类名&#123;//关键字 extends 类体 = 属性 + 方法&#125;// 私有的不支持继承// 构造方法不支持继承// 其他数据都可以被继承 虽然 java 语言当中只支持单继承，但是一个类也可以间接继承其它类，例如：1234567C extends B&#123;&#125;B extends A&#123;&#125;A extends T&#123;&#125;// C 直接继承 B 类，但是 C 类间接继承 T、A类 java 中假设一个类没有显示的继承任何类，该类默认继承 JavaSE 库当中提供的 java.lang.Object 类 123456789101112131415161718192021222324package com.day1403;public class ExtendsTest02 &#123; public static void main(String[] args) &#123; C c = new C(); //B 继承 A ，C 继承 B ，即 C 间接继承 A，所以 c. 可以访问 A 中的 doSome(); 方法 c.doSome(); &#125;&#125;class A&#123; public void doSome() &#123; System.out.println(\"do some!\"); &#125;&#125;class B extends A&#123; &#125;class C extends B&#123; &#125; 方法覆盖123456789101112131415161718192021关于 java 语言当中方法的覆盖： 1、方法覆盖又被称为方法重写，override/overwrite 2、什么时候使用方法重写 当父类中的方法已经无法满足当前子类的业务需求 子类有必要将父类中继承过来的方法进行重新编写 这个重新编写的过程称为方法重写/方法覆盖 3、什么条件满足之后方法会发生重写呢 [代码满足什么条件之后，就构成方法的覆盖呢] 方法重写发生在具有继承关系的父子类之间 返回值类型相同，方法名相同，形参列表相同 访问权限不能更低，可以更高 抛出异常不能更多，可以更少 [以后讲] 4、建议方法重写的时候尽量复制粘贴，不要编写，容易出错，导致没有产生覆盖 5、注意： 私有方法不能继承，所以不能覆盖 构造方法不能继承，所以不能覆盖 静态方法不存在覆盖 覆盖只针对方法，不谈属性 eg. 新建一个 Animal.java 12345678910package com.day1404;//动物类public class Animal &#123; //动物都是可以移动的 public void move() &#123; System.out.println(\"动物在移动\"); &#125;&#125; 新建一个 Bird.java 去继承 Animal ，此时鸟儿是在飞，要满足鸟儿飞就需要方法覆盖 1234567891011package com.day1404;//飞禽类public class Bird extends Animal&#123; //方法覆盖 public void move() &#123; System.out.println(\"鸟儿在飞行\"); &#125;&#125; 新建一个 Cat.java 去继承 Animal ，此时猫应该是走猫步，满足这个条件需要方法覆盖 123456789package com.day1404;//猫科类public class Cat extends Animal&#123; public void move() &#123; System.out.println(\"猫在走猫步\"); &#125;&#125; 建一个测试 OverrideTest01.java 1234567891011121314151617public class OverrideTest01 &#123; public static void main(String[] args) &#123; //创建动物对象 Animal a = new Animal(); a.move(); //动物在移动 //创建猫科类动物对象 Cat c = new Cat(); c.move(); //猫在走猫步 //创建飞禽类动物对象 Bird b = new Bird(); //鸟儿在飞行 b.move(); &#125;&#125; 多态多态语法机制，暂时参考上面的 Animal.java 和 Cat.java使用多态语法机制：1234Animal a1 = new Cat(); //向下类型转换 父类 --&gt; 子类Cat c1 = (Cat)a1;//当调用的方法或者访问的属性是子类型中特有的，在父类型当中不存在，必须进行向下转型 eg. 修改 Cat.java 123456789101112131415161718package com.day1405;//猫类public class Cat extends Animal&#123; //重写父类中继承过来的方法 public void move() &#123; //！！！super 关键字 //若重写后还是想要输出父类 Animal 的 move() 方法 //super.move(); //动物在移动 System.out.println(\"猫在溜达溜达\"); &#125; //子类对象特有的行为 public void catchMouse() &#123; System.out.println(\"猫抓老鼠！\"); &#125;&#125; 修改 Bird.java 123456789101112131415package com.day1405;//鸟儿类public class Bird extends Animal&#123; //重写 public void move() &#123; System.out.println(\"鸟儿在飞翔\"); &#125; public void fly() &#123; System.out.println(\"Bird Fly\"); &#125;&#125; 新建 Test.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.day1405;public class Test &#123; public static void main(String[] args) &#123; //使用多态语法机制 Animal a1 = new Cat(); // 子类 --&gt; 父类 称为向上转型 a1.move(); //猫在溜达溜达 //结果主要看底层对象，底层对象是 Cat 调用的方法也是 Cat 对象的方法 /* * 需求： * 假设想让以上的对象执行 catchMouse() 方法 * a2 是无法直接调用的，因为 a2 类型 Animal,Animal 中没有 catchMouse() 方法 * 我们可以将 a2 强制类型转换为 Cat 类型 * a2 的类型是 Animal（父类），转换成 Cat 类型（子类），被称为向下转型/downcasting/强制类型转换 * * 注：向下转型也需要两种类型之间必须有继承关系。不然编译器报错，强制类型转换需要加强制类型转换符 * * 什么时候需要使用向下转型呢 * 当调用的方法或者访问的属性是子类型中特有的，在父类型当中不存在，必须进行向下转型 * */ //向下转型 Cat c1 = (Cat)a1; c1.catchMouse(); //猫抓老鼠！ /* * long x = 100L; * int i = (int)i; */ Animal a2 = new Bird(); /* * 1、以下程序编译是没有问题的，因为编译器检查到 a2 的数据类型是 Animal，Animal 和 Cat 之间存在继承关系 * 并且 Animal 是父类型，Cat 是子类型，父类型转换成子类型叫做向下转型，语法合格 * * 2、程序虽然编译通过了，但是程序在运行阶段会出现异常，因为 JVM 堆内存当中真实存在的对象是 Bird 类型 * Bird 对象无法转换成 Cat 对象，因为两种类型之间不存在任何继承关系，此时出现了著名的异常： * java.lang.ClassCastException * 类型转换异常，这种异常总是在\"向下转型\"的时候会发生 * */ //Cat c2 = (Cat)a2; // Bird 和 Cat 不存在继承关系 /** * 1、以上异常只有在强制类型转换的时候会发生，也就是说\"向下转型\"存在隐患(编译通过，但是运行错误) * 2、向上转型只要编译通过，肯定可以运行 eg. Animal a = new Cat(); * 3、向下转型编译通过，运行可能错误 eg. Animal a2 = new Bird(); Cat c2 = (Cat)a2; * 4、怎么避免向下转型出现的 ClassCastException * 使用 instanceof 运算符可以避免出现以上的异常 * 5、instanceof 运算符： * 5.1、语法格式： * (引用 instanceof 数据类型名) * 5.2、以上运算符的执行结果类型是布尔类型，结果可能是 true/false * 5.3、关于运算结果 true/false * 假设：(a instanceof Animal) * true ： * a 这个引用指向的对象是一个 Animal 类型 * false： * a 这个引用指向的对象不是一个 Animal 类型 * 6、Java 规范中要求：在进行强制类型转换之前，建议采用 instanceof 运算符进行判断，避免 ClassCastException 出现 * */ if(a2 instanceof Cat) &#123;//a2 是一个 Cat 类型的对象 Cat c2 = (Cat)a2; c2.catchMouse(); &#125;else if(a2 instanceof Bird) &#123;//a3 是一个 Bird 类型的对象 Bird b2 = (Bird)a2; b2.fly(); &#125; &#125;&#125; eg. 多态在实际开发中的应用，主人喂养宠物 创建一个 Master.java 1234567891011package com.day1501;public class Master&#123; //Master 主人类面向的是一个抽象的 Pet，不再面向具体的宠物 //提倡：面向抽象编程，不要面向具体编程 //面向抽象编程的好处是，耦合度低，扩展力强 public void feed(Pet pet) &#123;// Pet pet 是一个父类型的引用 pet.eat(); &#125;&#125; 创建一个 Pet.java 1234567891011package com.day1501;/* * 宠物 */public class Pet &#123; //所有的宠物都可以吃东西 public void eat() &#123; &#125;&#125; 创建一个 Cat.java 12345678910111213package com.day1501;/* * 宠物小猫 */public class Cat extends Pet&#123; //小猫爱吃鱼 public void eat() &#123; System.out.println(\"小猫在吃鱼！\"); &#125;&#125; 创建一个 Dog.java 1234567891011121314package com.day1501;/** * 宠物小狗 * @author SUMMER * */public class Dog extends Pet&#123; public void eat() &#123; System.out.println(\"小狗正在啃骨头！\"); &#125;&#125; 创建一个 Test.java 用于测试 123456789101112131415161718192021222324252627282930313233343536package com.day1501;/* * 多态在实际开发中的作用，以下主人喂养宠物为例说明多态的作用： * 1、分析：主人喂养宠物这个场景要实现需要进行类型的抽象： * - 主人 [类] * - 主人可以喂养宠物，所以主人有喂养的这个动作 * - 宠物 [类] * - 宠物可以吃东西，所以宠物有吃东西的这个动作 * * 2、面向对象编程的核心：定义好类，然后将类实例化为对象，给一个环境驱使一下， * 让各个对象之间协作起来形成一个系统 * * 3、多态的作用 * 降低程序的耦合度，提高程序的扩展里 * 能使用多态尽量使用多态 * 父类型引用指向子类型对象 * * 核心：面向抽象编程，尽量不要面向具体编程 */public class Test &#123; public static void main(String[] args) &#123; //创建主人对象 Master WiHieree = new Master(); //创建猫对象 Cat beer = new Cat(); //主人喂养猫 WiHieree.feed(beer); //创建小狗对象 Dog yt = new Dog(); //主人喂小狗 WiHieree.feed(yt); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://wiyeelu.github.io/tags/Java/"},{"name":"Method","slug":"Method","permalink":"https://wiyeelu.github.io/tags/Method/"}]},{"title":"Java Method","slug":"Java Method","date":"2019-03-21T09:27:37.000Z","updated":"2019-06-21T00:58:04.000Z","comments":true,"path":"2019/03/21/Java Method/","link":"","permalink":"https://wiyeelu.github.io/2019/03/21/Java Method/","excerpt":"学习 Java 方法后的一些理解与总结","text":"学习 Java 方法后的一些理解与总结 一个 Java 方法是为了执行某个操作的一些语句的组合，本质是一段代码片段。 1234方法定义在类体当中，在一个类当中可以定义多个方法方法编写的位置没有先后顺序，可以随意方法体当中不能再定义方法！！！！方法体由 java 语句构成，方法体当中的代码遵守自上而下的顺序依次执行 创建方法123public static int stuAge(int a)&#123; // method&#125; public static：修饰符 可选项，不是必须的 int：返回值类型 返回值类型可以是 Java 任意一种类型，包括基本数据类型和所有的引用数据类型 也可能一个方法执行结束之后不返回任何数据，此时应使用 void 关键字 返回值类型不是 void 的时候，表示这个方法执行结束之后必须返回一个具体的值 return 值; //值的数据类型必须和方法的返回值一致，否则编译报错eg. 拥有返回值类型的方法，定义方法计算两个 int 类型数据的商123456public static int divide(int a,int b)&#123; return a / b; //已经执行 return 语句即结束当前方法 //System.out.println(\"Wihieree\"); //编译报错，因为永远不会执行 sout&#125; 当返回值为空的时候使用 return; 语句是为了结束当前方法 stuAge：方法名 合法的标识符 见名知意 首字母要求小写，后面每个单词首字母大写 stuAge stuName maxNumFuntion a：形参（形式参数） 可选项，不是必须 形参是局部变量 多个形参之间用 “逗号” 隔开，要求类型对应相同，类型不同的时候要求能够进行相应的自动类型转换 int a,int b,int c 形参中起决定性作用的是形参的数据类型，形参的名字就是局部变量的名字 int a：参数列表 方法再调用的时候，实际给这个方法传递的真实数据被称为：实际参数，简称实参 实参列表和形参列表必须满足 数量相同 类型对应相同1234567//定义一个 sum 方法public static int sum(int a,int b)&#123; //int a,int b 是形参列表&#125;//方法调用//sum(\"abc\",\"def\"); //编译报错sum(10,20); eg. 定义一个 max() 方法，接受 num1 和 num2 两个参数并返回两者之间的最大值123456789public static int maxFunt(int num1, int num2) &#123; int max; if (num1 &gt; num2) &#123; max = num1; &#125;else &#123; max = num2; &#125; return max; &#125; 方法调用方法只定义不去调用时不会执行的，只有在调用的时候才会执行 语法规则：12&lt;方法的修饰符列表当中有 static &gt;类名.方法名(实参列表)；这是一条 java 语句，表示调用某个类的某个方法，传递这样的实参 eg.1234567891011121314151617181920212223242526272829303132333435363738394041424344//public 表示公开的//class 表示定义类// MethodTest03 是一个类名public class MethodTest03 &#123; //表示定义一个公开的类 MethodTest03，由于是公开的类，所以源文件名必须为 MethodTest03 //类体 //类体中不能直接编写 java 语句，除声明变量之外 //方法出现在类体当中 //方法 //public 表示公开的 //static 表示静态的 //void 表示方法执行结束之后不返回任何数据 //main 是方法名:主方法 //(String[] args)：形式参数列表，其中String[]是一种引用数据类型，args 是一个局部变量的变量名 //以下只有 args 这个局部变量的变量名是随意的 //主方法就需要这样固定编写，这是程序的入口（SUN 规定的，必须这样写） public static void main(String[] args)&#123; //这里的程序是一定会执行的 //main 方法是 JVM 负责调用的，是一个入口位置 //从这里作为起点开始执行程序 //在这里调用其它方法 //调用 MethodTest03 的 sum 方法，传递两个实参 MethodTest03.sum(10,20); //实参 //一个方法可以被重复使用，重复调用 int a = 300; MethodTest03.sum(a,500); &#125; //自定义方法：不是程序的入口 //方法作用：计算两个 int 类型数据的和，不要求返回结果，但是要求将结果直接输出到控制台 //修饰符列表：public static //返回值类型：void //方法名：sum //形式参数列表：（int x,int y） //方法体：主要任务是求和之后输出计算结果 public static void sum(int i,int j)&#123;//形参 System.out.println(i + \" + \" + j + \" = \" + (i + j)); &#125;&#125; 参数的值传递在调用函数时参数是必须被传递的，并且他们的次序必须和他们创建时的参数次序是一样的，参数可以通过值或引用来传递eg. 通过值来传递参数123456789101112131415public class CanShuTest01 &#123; public static void main(String[] args) &#123; int i = 10; add(i); System.out.println(\"main --&gt;&gt; \" + i); // 10 这里的值是 main 方法里的 i 的值 &#125; public static void add(int i) &#123; i++; System.out.println(\"add --&gt;&gt; \" + i); // 11 &#125;&#125; eg. 通过值来传递参数，当传递的是内存地址的时候12345678910111213141516171819202122232425public class CanShuTest02 &#123; public static void main(String[] args) &#123; User1 u = new User1(20); add(u); System.out.println(\"main --&gt;&gt; \" + u.age);//21 //因为这里的 u 指向的 User1 对象的 age 值在 add 方法 //里修改成了 21 &#125; //User1 u 形参 public static void add(User1 u) &#123; u.age++; System.out.println(\"add --&gt;&gt; \" + u.age); //21 &#125;&#125;class User1&#123; //实例变量 int age; //构造方法 public User1(int i) &#123; age = i; &#125;&#125; 方法重载 overload当一个方法有两个或者更多的方法，他们的名字一样但是参数不同时，就叫做方法的重载它与覆盖是不同的，覆盖是指方法具有相同的名字，类型以及参数的个数方法重载的优点： 程序员调用方法的时候，比较方便，虽然调用的是不同的方法，但是就感觉在调用同一个方法，不需要记忆更多的方法名 方法重载的条件： 在同一个类当中 方法名相同 参数列表不同：数量、顺序、类型不同 方法重载和方法名 + 参数列表有关系 方法重载和返回值类型、修饰符列表无关eg. 定义一个计算两个 int 类型、long 类型、double 类型 数据的和的方法123456789101112131415161718192021public class OverloadTest01 &#123; public static void main(String[] args)&#123; System.out.println(sum(1,2)); //3 System.out.println(sum(1.3,2.5)); //3.8 System.out.println(sum(10L,20L)); //30 &#125; public static int sum(int a,int b)&#123; return a + b; &#125; public static long sum(long a,long b)&#123; return a + b; &#125; public static double sum(double a,double b)&#123; return a + b; &#125;&#125; 方法递归方法递归即为方法自身调用自身123a()&#123; a();&#125; 递归是很耗费栈内存的，递归算法可以不用的时候尽量别用递归必须有结束条件，没有结束条件一定会发生栈溢出错误12345678910111213public class RecursionTest01 &#123; //主方法 public static void main(String[] args)&#123; //调用 doSome 方法 doSome(); &#125; // doSome 会被重复调用 public static void doSome()&#123; System.out.println(\"doSome begin\"); doSome();//这行代码不结束，下一行程序是无法运行的 System.out.println(\"doSome over\"); &#125;&#125; 递归即使有了结束条件，即使结束条件是正确的，也可能会发生栈内存溢出错误，因为递归太深了主要应用为目录拷贝eg. 使用递归计算 1~N 的求和123456789101112131415161718public class RecursionTest03 &#123; public static void main(String[] args)&#123; //1~4 的和 int n = 4; int retValue = sum(n); System.out.println(retValue); &#125; public static int sum(int n)&#123; // 4 + 3 + 2 + 1 if (n == 1)&#123; return 1; &#125; return n + sum(n-1); &#125;&#125; 构造方法（构造函数 / 构造器 / Constructor）构造方法的作用：构造方法存在的意义是通过构造方法的调用，可以创建对象当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值成员变量之实例变量，属于对象级别的变量，这种变量必须先有对象才能有实例变量实例变量没有手动赋值的时候，系统默认赋值，在构造方法执行过程中完成的赋值12345678910构造方法语法结构：[修饰符列表] 构造方法名(形式参数列表)&#123; 构造方法体;&#125;//虽然构造方法语法没有返回值类型，但是构造方法执行之后有返回值普通方法的语法结构：[修饰符列表] 返回值类型 方法名(形式参数列表)&#123; 方法体;&#125; 对于构造方法来说，”返回值类型”不需要指定，并且也不能写 void, 只要写上 void，那么这个方法就是普通方法通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象当一个类中没有定义任何构造方法的话，系统默认给该类提供一个无参数的构造方法，这个构造方法被称为缺省构造器当一个类显示的将构造方法定义出来了，那么系统则不再默认为这个类提供缺省构造器；建议开发中手动的为当前类提供无参数构造方法构造方法支持重载机制 在 Java 类和对象的封装中进行补充说明 static 关键字123451. static 译为 静态的2. static 修饰的方法是静态方法3. static 修饰的变量是静态变量4. 所有 static 修饰的元素都称为静态的，都可以使用&quot;类名.&quot;的方式访问， 当然也可以用&quot;引用.&quot;的方式访问（但是不建议） 方法定义为静态的情况：1231. 方法描述的是动作，当所有的对象执行这个动作的时候，最终产生影响是一样的，那么这个动作已经不再属于某一对象动作了，可以将这个动作提升为类级别的动作，模板级别的动作2. 静态方法中无法直接访问实例变量和实例方法3. 大多数方法都定义为实例方法，一般一个行为或者一个动作在发生的时候，都需要对象的参与，但是也有例外，例如：大多数&quot;工具类&quot;中的方法都是静态方法，因为工具类就是方便编程，为了方便方法的调用，自然不需要 new 对象是最好的","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://wiyeelu.github.io/tags/Java/"},{"name":"Method","slug":"Method","permalink":"https://wiyeelu.github.io/tags/Method/"}]}]}